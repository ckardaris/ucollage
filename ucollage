#!/usr/bin/env bash
shopt -s extglob
declare -A map_cmd
declare -A colon_cmd
declare -A optiontype=(\
    [execprompt]="boolean"
    [showfileinfo]="boolean"
    [reverse]="boolean"
    [scaler]="enum"
    [sort]="enum"
    [fileinfo]="enum"
    [gridcolumns]="number"
    [gridlines]="number"
    [maxload]="number"
    [scalingx]="number"
    [scalingy]="number"
)

declare -A enumoptvalue=(\
    [scaler]="crop distort fit_contain contain forced_cover cover"
    [sort]="name time size extension"
    [fileinfo]="names ratings"
)

declare -A spacelist=(\
    [batch]="previous next first last"
    [rate]="0 1 2 3 4 5"
    [set]="${!optiontype[*]}"
    [!]="$(compgen -c | tr '\n' ' ')"
    [!%]="$(compgen -c | tr '\n' ' ')"
)

declare -A sticklist=(\
    [no]="showfileinfo execprompt reverse"
    [inv]="showfileinfo execprompt reverse"
)
for key in ${!enumoptvalue[*]}
do
    sticklist[$key=]="${enumoptvalue[$key]}"
    sticklist[$key:]="${enumoptvalue[$key]}"
done

declare -A optdefault
declare -A optcurrent
declare -A optupdate=(\
    [execprompt]="message+=\${optcurrent[execprompt]}"
    [showfileinfo]="redraw"
    [reverse]="update_reverse"
    [scaler]="show_batch"
    [sort]="break_flag=1"
    [fileinfo]="update_fileinfo"
    [gridcolumns]="redraw"
    [gridlines]="redraw"
    [maxload]=""
    [scalingx]="set_scaling; show_batch"
    [scalingy]="set_scaling; show_batch"
)

CONFIG_VARIABLES_FILE="$HOME/.config/ucollage/variables"
CONFIG_SCRIPTS_FILE="$HOME/.config/ucollage/scripts"
CONFIG_DEFAULT="/etc/ucollage/mappings"

trim_spaces() {
    local -n str="$1"
    local char
    str="${str##*([[:space:]])}"
    str="${str%%*([[:space:]])}"
    str="${str//+([[:space:]])/ }"
    for delim in $2
    do
        str="${str//*([[:space:]])${delim}*([[:space:]])/${delim}}"
    done
}

translate_map() {
    local -n str="$1"
    str=${str//<Leader>/$leader}
    str=${str//<Ctrl-A>/$'\x1'}
    str=${str//<Ctrl-B>/$'\x2'}
    str=${str//<Ctrl-C>/$'\x3'}
    str=${str//<Ctrl-D>/$'\x4'}
    str=${str//<Ctrl-E>/$'\x5'}
    str=${str//<Ctrl-F>/$'\x6'}
    str=${str//<Ctrl-G>/$'\x7'}
    str=${str//<Ctrl-H>/$'\x8'}
    str=${str//<Backspace>/$'\x8'}
    str=${str//<Ctrl-I>/$'\x9'}
    str=${str//<Tab>/$'\x9'}
    str=${str//<Shift-Tab>/$'\x1B'$'\x5B'$'\x5A'}
    str=${str//<Ctrl-J>/$'\xA'}
    str=${str//<Ctrl-K>/$'\xB'}
    str=${str//<Ctrl-L>/$'\xC'}
    str=${str//<Ctrl-M>/$'\xD'}
    str=${str//<Return>/$'\xD'}
    str=${str//<Enter>/$'\xD'}
    str=${str//<Ctrl-N>/$'\xE'}
    str=${str//<Ctrl-O>/$'\xF'}
    str=${str//<Ctrl-P>/$'\x10'}
    str=${str//<Ctrl-Q>/$'\x11'}
    str=${str//<Ctrl-R>/$'\x12'}
    str=${str//<Ctrl-S>/$'\x13'}
    str=${str//<Ctrl-T>/$'\x14'}
    str=${str//<Ctrl-U>/$'\x15'}
    str=${str//<Ctrl-V>/$'\x16'}
    str=${str//<Ctrl-W>/$'\x17'}
    str=${str//<Ctrl-X>/$'\x18'}
    str=${str//<Ctrl-Y>/$'\x19'}
    str=${str//<Ctrl-Z>/$'\x1A'}
    str=${str//<Insert>/$'\x1B'$'\x5B'$'\x32'$'\x7e'}
    str=${str//<Ctrl-Insert>/$'\x1B'$'\x5B'$'\x32'$'\x3B'$'\x35'$'\x7e'}
    str=${str//<Shift-Insert>/$'\x1B'$'\x5B'$'\x32'$'\x3B'$'\x32'$'\x7e'}
    str=${str//<Delete>/$'\x1B'$'\x5B'$'\x33'$'\x7e'}
    str=${str//<Ctrl-Delete>/$'\x1B'$'\x5B'$'\x33'$'\x3B'$'\x35'$'\x7e'}
    str=${str//<Shift-Delete>/$'\x1B'$'\x5B'$'\x33'$'\x3B'$'\x32'$'\x7e'}
    str=${str//<Ctrl-Shift-Delete>/$'\x1B'$'\x5B'$'\x33'$'\x3b'$'\x36'$'\x7e'}
    str=${str//<Home>/$'\x1B'$'\x5B'$'\x48'}
    str=${str//<Ctrl-Home>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x48'}
    str=${str//<Shift-Home>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x48'}
    str=${str//<Ctrl-Shift-Home>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x48'}
    str=${str//<End>/$'\x1B'$'\x5B'$'\x46'}
    str=${str//<Ctrl-End>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x46'}
    str=${str//<Shift-End>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x46'}
    str=${str//<Ctrl-Shift-End>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x46'}
    str=${str//<PageUp>/$'\x1B'$'\x5B'$'\x35'$'\x7e'}
    str=${str//<Ctrl-PageUp>/$'\x1B'$'\x5B'$'\x35'$'\x3B'$'\x35'$'\x7e'}
    str=${str//<PageDown>/$'\x1B'$'\x5B'$'\x36'$'\x7e'}
    str=${str//<Ctrl-PageDown>/$'\x1B'$'\x5B'$'\x36'$'\x3B'$'\x35'$'\x7e'}
    str=${str//<F1>/$'\x1B'$'\x4F'$'\x50'}
    str=${str//<F2>/$'\x1B'$'\x4F'$'\x51'}
    str=${str//<F3>/$'\x1B'$'\x4F'$'\x52'}
    str=${str//<F4>/$'\x1B'$'\x4F'$'\x53'}
    str=${str//<F5>/$'\x1B'$'\x5B'$'\x31'$'\x35'$'\x7e'}
    str=${str//<F6>/$'\x1B'$'\x5B'$'\x31'$'\x37'$'\x7e'}
    str=${str//<F7>/$'\x1B'$'\x5B'$'\x31'$'\x38'$'\x7e'}
    str=${str//<F8>/$'\x1B'$'\x5B'$'\x31'$'\x39'$'\x7e'}
    str=${str//<F9>/$'\x1B'$'\x5B'$'\x32'$'\x30'$'\x7e'}
    str=${str//<F10>/$'\x1B'$'\x5B'$'\x32'$'\x31'$'\x7e'}
    str=${str//<F11>/$'\x1B'$'\x5B'$'\x32'$'\x33'$'\x7e'}
    str=${str//<F12>/$'\x1B'$'\x5B'$'\x32'$'\x34'$'\x7e'}
    str=${str//<Up>/$'\x1B'$'\x5B'$'\x41'}
    str=${str//<Down>/$'\x1B'$'\x5B'$'\x42'}
    str=${str//<Right>/$'\x1B'$'\x5B'$'\x43'}
    str=${str//<Left>/$'\x1B'$'\x5B'$'\x44'}
    str=${str//<Ctrl-Up>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x41'}
    str=${str//<Ctrl-Down>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x42'}
    str=${str//<Ctrl-Right>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x43'}
    str=${str//<Ctrl-Left>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x35'$'\x44'}
    str=${str//<Shift-Up>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x41'}
    str=${str//<Shift-Down>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x42'}
    str=${str//<Shift-Right>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x43'}
    str=${str//<Shift-Left>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x32'$'\x44'}
    str=${str//<Ctrl-Shift-Up>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x41'}
    str=${str//<Ctrl-Shift-Down>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x42'}
    str=${str//<Ctrl-Shift-Right>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x43'}
    str=${str//<Ctrl-Shift-Left>/$'\x1B'$'\x5B'$'\x31'$'\x3B'$'\x36'$'\x44'}
}

set_scripts(){
    local -a file_data
    local ci command errors=0 i info line map mi script type
    # First we map the builtin commands and then the user defined. The order is
    # that way so that the user can override the defaults.
    if [[ -f "$CONFIG_DEFAULT" ]] && [[ -f "$CONFIG_SCRIPTS_FILE" ]]
    then
        mapfile -t file_data < <(cat "$CONFIG_DEFAULT" "$CONFIG_SCRIPTS_FILE")
    elif [[ ! -f "$CONFIG_DEFAULT" ]]
    then
        echo "Error: Default mappings and commands not found"
        echo "Location: $CONFIG_DEFAULT"
        echo "--------------------"
        read -rsN1
        mapfile -t file_data < "$CONFIG_SCRIPTS_FILE"
    else
        mapfile -t file_data < "$CONFIG_DEFAULT"
    fi
    for ((i = 0; i < ${#file_data[@]}; i++))
    do
        line=${file_data[$i]}
        trim_spaces line "[ ]"
        if [[ "$line" =~ ^\[.*\]$ ]]
        then
            info=${line#[}
            info=${info%]}

            type=${file_data[$((i + 1))]##type}
            trim_spaces type

            map=${file_data[$((i + 2))]##map}
            trim_spaces map
            translate_map map

            script=${file_data[$((i + 3))]##script}
            trim_spaces script

            command=${file_data[$((i + 4))]##command}
            trim_spaces command

            if [[ "$type" == "edit" ]]
            then
                if [[ ! "$script" =~ %in% ]]
                then
                    echo "Error: configuration"
                    echo "--------------------"
                    echo "Value: $script"
                    echo "Valid: %in% placeholder missing"
                    echo "--------------------"
                    errors=1
                elif [[ ! "$script" =~ %out% ]]
                then
                    echo "Error: configuration"
                    echo "--------------------"
                    echo "Value: $script"
                    echo "Valid: %out% placeholder missing"
                    echo "--------------------"
                    errors=1
                else
                    for mi in $map
                    do
                        # <Space> has to be substituted here or else it is split
                        # by the 'for' expansion
                        mi=${mi//<Space>/ }
                        map_cmd[$mi]="run_edit_script \"${script}\""
                    done
                    for ci in $command
                    do
                        colon_cmd[$ci]="run_edit_script \"${script}\""
                    done
                fi
            elif [[ "$type" == "use" ]]
            then
                for mi in $map
                do
                    # <Space> has to be substituted here or else it is split
                    # by the 'for' expansion
                    mi=${mi//<Space>/ }
                    map_cmd[$mi]="run_use_script \"${script}\" \"${info}\""
                done
                for ci in $command
                do
                    colon_cmd[$ci]="run_use_script \"${script}\" \"${info}\""
                done
            elif [[ "$type" == "builtin" ]]
            then
                # Usage of the --- delimiter makes possible that some commands
                # have a default value in map normal mode, but permit input
                # in command mode
                # e.g tp
                #     toggle prompt (normal mode)
                #     toggle (command mode - shared also by tf and tr)
                for mi in $map
                do
                    # <Space> has to be substituted here or else it is split
                    # by the for expansion
                    mi=${mi//<Space>/ }
                    map_cmd[$mi]="${script/---/ }"
                done
                for ci in $command
                do
                    colon_cmd[$ci]="${script}"
                done
            fi
            ((i += 4))
        fi
    done
    [[ "$errors" -eq 1 ]] && read -rsN1
    spacelist[ucollage]="${!colon_cmd[*]}"
}

check_config_variable() {
    [[ -z "${!variable_name}" ]] && return
    eval "[[ \"${!variable_name}\" =~ $accept_regexp ]]" && return
    if [[ "$errors" -eq 0 ]]
    then
        echo "Error: configuration"
        echo "--------------------"
    fi
    echo "[$variable_name]"
    echo "Value: ${!variable_name}"
    echo "Valid: $valid_values"
    echo "--------------------"
    eval "${variable_name}=" #unset the variable
    errors=1
}

parse_config() {
    local accept_regexp errors=0 valid_values variable_name

    variable_name="UCOLLAGE_LINES"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$" # is natural
    valid_values="natural numbers"
    check_config_variable

    variable_name="UCOLLAGE_COLUMNS"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$"
    valid_values="natural numbers"
    check_config_variable

    variable_name="UCOLLAGE_EXEC_PROMPT"
    accept_regexp="^(no|)execprompt$"
    valid_values="noexecprompt, execprompt"
    check_config_variable

    variable_name="UCOLLAGE_SHOW_FILEINFO"
    accept_regexp="^(no|)showfileinfo$"
    valid_values="noshowfileinfo, showfileinfo"
    check_config_variable

    variable_name="UCOLLAGE_FILEINFO"
    accept_regexp="^(names|ratings)$"
    valid_values="names, ratings"
    check_config_variable

    variable_name="UCOLLAGE_EXPAND_DIRS"
    accept_regexp="^(0|1|ask)$"
    valid_values="0, 1, ask"
    check_config_variable

    variable_name="UCOLLAGE_SORT"
    accept_regexp="^(name|time|size|extension)$"
    valid_values="name, time, size, extension"
    check_config_variable

    variable_name="UCOLLAGE_SORT_REVERSE"
    accept_regexp="^(no|)reverse$"
    valid_values="noreverse, reverse"
    check_config_variable

    variable_name="UCOLLAGE_SCALER"
    accept_regexp="^(crop|distort|fit_contain|contain|forced_cover|cover)$"
    valid_values="crop, distort, fit_contain, contain, forced_cover, cover"
    check_config_variable

    variable_name="UCOLLAGE_VIDEO_THUMBNAILS"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_CACHE_THUMBNAILS"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_THUMBNAIL_WIDTH"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$" # is natural
    valid_values="natural numbers"
    check_config_variable

    variable_name="UCOLLAGE_MAX_LOAD"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$" # is natural
    valid_values="natural numbers"
    check_config_variable

    [[ "$errors" -eq 1 ]] && read -rsN1 -p "Using default variables..." && echo
}

set_default() {
    optdefault[gridlines]=${UCOLLAGE_LINES:-3}
    optdefault[gridcolumns]=${UCOLLAGE_COLUMNS:-3}
    optdefault[execprompt]=${UCOLLAGE_EXEC_PROMPT:-execprompt}
    optdefault[showfileinfo]=${UCOLLAGE_SHOW_FILEINFO:-showfileinfo}
    optdefault[fileinfo]=${UCOLLAGE_FILEINFO:-names}
    optdefault[sort]=${UCOLLAGE_SORT:-time}
    optdefault[reverse]=${UCOLLAGE_SORT_REVERSE:-noreverse}
    optdefault[scaler]=${UCOLLAGE_SCALER:-contain}
    optdefault[scalingx]=${UCOLLAGE_SCALINGX:-50}
    optdefault[scalingy]=${UCOLLAGE_SCALINGY:-50}
    optdefault[maxload]=${UCOLLAGE_MAX_LOAD:-1000}
    wide_vertical="${optdefault[gridlines]}"
    wide_horizontal="${optdefault[gridcolumns]}"
    tmp_dir=${UCOLLAGE_TMP_DIR:-/tmp/ucollage}
    cache_dir=${UCOLLAGE_CACHE_DIR:-~/.local/share/ucollage}
    trash_dir=${UCOLLAGE_TRASH_DIR:-~/.local/share/Trash/ucollage}
    expand_dirs=${UCOLLAGE_EXPAND_DIRS:-ask}
    video_thumbnails=${UCOLLAGE_VIDEO_THUMBNAILS:-1}
    cache_thumbnails=${UCOLLAGE_CACHE_THUMBNAILS:-1}
    thumbnail_width=${UCOLLAGE_THUMBNAIL_WIDTH:-500}
    leader=${UCOLLAGE_LEADER:-\\}
    error=""
    warning=""
    success=""
    message=""
    prefix=""
    exit_clear=1
    previous_batch=0
}

set_optcurrent() {
    for key in "${!optdefault[@]}"
    do
        optcurrent[$key]="${optdefault[$key]}"
    done
    set_scaling
}

help(){
    echo "Usage: ucollage [images] [directories]"
    echo
    echo "Controls:"
    echo "  Backspace            exit monocle mode"
    echo "  :                    enter command mode"
    echo "  .                    repeat last action (a new prefix must be given)"
    echo "  n/right arrow        get next batch of images"
    echo "  N/shift+right arrow  get last batch of images"
    echo "  p/left arrow         get previous batch of images"
    echo "  P/shift+left arrow   get first batch of images"
    echo "  tp                   toggle exec prompt"
    echo "  tn                   toggle filenames on screen"
    echo "  ss                   set sort type"
    echo "  tr                   toggle reverse sort"
    echo "  su                   set ueberzug scaler"
    echo "  q                    exit"
    echo
    echo "Controls with vim-like prefix counters"
    echo "  (N)-        decrease both the numbers of columns and lines by N"
    echo "  (N)+/=      increase both the numbers of columns and lines by N"
    echo "  (N)ci       rename image with index N"
    echo "  (N)di       move image with index N to Trash"
    echo "  (N)u        undo edits of image with index N"
    echo "  (N)Ctrl+r   redo edits of image with index N"
    echo "  (N)r        rotate clockwise image with index N"
    echo "  (N)R        rotate counter-clockwise image with index N"
    echo "  (N)h        decrease number of columns by N"
    echo "  (N)j        decrease number of lines by N"
    echo "  (N)k        increase number of lines by N"
    echo "  (N)l        increase number of columns by N"
    echo "  (N)gi       enter monocle mode; go to image with index N"
    echo "  (N)sg       set grid size"
    echo "  (N)ti       tag image with index N"
    echo "  (N)dt       untag image with index N"
    echo "  (N)wi       save edits of image with index N"
    echo "  (N)xi       execute different commands for each image with index N"
    echo "              placeholders are available for command execution"
    echo "                  %s - image filename"
    echo "                  %e - edited image filename"
    echo "  (N)xs       execute same command for each image with index N"
    echo "              placeholders are available for command execution"
    echo "                  %s - image filename"
    echo "                  %e - edited image filename"
    echo "  (N)xg       execute one command for all images with index N"
    echo "              placeholders"
    echo "                  %S - all image filenames side by side"
    echo "                  %E - all edited image filenames side by side"
}

check_dependencies() {
    local dependency errors=0
    local -A dep
    dep[ueberzug]="ueberzug"
    dep[file]="file"
    dep[xxh128sum]="xxhash"
    dep[bc]="bc"
    for dependency in "${!dep[@]}"
    do
        if ! command -v "$dependency" &>/dev/null
        then
            echo "Required dependency not installed: ${dep[$dependency]}" && exit
        fi
    done
    dep=()
    dep[convert]="imagemagick"
    dep[ffmpeg]="ffmpeg"
    dep[xclip]="xclip"
    for dependency in "${!dep[@]}"
    do
        if ! command -v "$dependency" &>/dev/null
        then
            errors=1
            echo "Optional dependency not installed: ${dep[$dependency]}"
        fi
    done
    [[ "$errors" -eq 1 ]] && read -rsN1
}

######################################################################
# Create filelist
######################################################################
read_filenames() {
    local char item ls_args="-d"
    [[ "${optcurrent[reverse]}" == "reverse" ]] && ls_args+=" -r"
    case "${optcurrent[sort]}" in
        "time")
            ls_args+=" -t"
            ;;
        "size")
            ls_args+=" -S"
            ;;
        "extension")
            ls_args+=" -X"
            ;;
    esac
    if [[ "$#" -gt 0 ]]
    then
        mapfile -t filelist < <(ls $ls_args "$@")
    else
        mapfile -t filelist < <(ls $ls_args -- *)
    fi
    if [[ "$expand_dirs" -eq 1 ]]
    then
        for item in "${filelist[@]}"
        do
            [[ -d "$item" ]] && filelist+=("$item"/*)
        done
    elif [[ "$expand_dirs" == "ask" ]]
    then
        for item in "${filelist[@]}"
        do
            [[ -d "$item" ]] \
                && read -p "Expand $item? (n, Esc: no, N: no to all)" -rsN1 char \
                && echo
            [[ "$char" == "N" ]] && break
            [[ ! "$char" =~ ^(n|$'\e')$ ]] && filelist+=("$item"/*)
        done
    fi
    argc="${#filelist[@]}"
    image_names=()
    images=()
    filehash=()
    rm -f "${tmp_dir}/image_names.txt*"
    rm -f "${tmp_dir}/images.txt*"
    rm -f "${tmp_dir}/hash.txt*"
}

######################################################################
# Search for thumbnail of file in cache directory
######################################################################
find_thumbnail() {
    cache_name="${cache_dir}/thumbnails/${hash}.jpg"
    [[ -f "$cache_name" ]] && thumbnail_file="$cache_name" && return 0
    return 1
}

######################################################################
# Create thumbnail for file
######################################################################
create_thumbnail() {
    local format_duration time_point
    thumbnail_file="${tmp_dir}/${hash}.jpg"
    eval "$(ffprobe -i "$file" -show_entries format=duration \
        -v quiet -of flat="s=_")"
    format_duration=${format_duration/.*/}
    (( time_point = format_duration / 2 ))
    ffmpeg -ss "$time_point" -i "$file" -loglevel quiet -frames:v 1 \
        -filter:v scale="$thumbnail_width":-1 -y "$thumbnail_file"
    montage -label "thumbnail" "$thumbnail_file" -geometry +0+0 \
        -background Gold "$thumbnail_file"
}

is_image() {
    [[ -f "${cache_dir}/hash/images/${hash}" ]] && return 0
    if [[ $(file --mime-type -b "$file") =~ ^image/.*$ ]]
    then
        touch "${cache_dir}/hash/images/${hash}"
        return 0
    fi
    return 1
}

is_video() {
    [[ -f "${cache_dir}/hash/videos/${hash}" ]] && return 0
    if [[ $(file --mime-type -b "$file") =~ ^video/.*$ ]]
    then
        touch "${cache_dir}/hash/videos/${hash}"
        return 0
    fi
    return 1
}
######################################################################
# Parses filelist and filters supported filetypes
######################################################################
read_images() {
    echo 1 > "${tmp_dir}/read_lock"
    local file loadc=0 readc=0 thumbnail_file
    while (( readc < read_target )) && (( read_iter < argc )) && \
        ((loadc < optcurrent[maxload]))
    do
        file=${filelist[$read_iter]}
        read -rd ' ' hash < <(head -c 100000 "$file" 2>/dev/null | xxh128sum)
        if is_image "$file"
        then
            echo "$file" >> "${tmp_dir}/image_names.txt"
            echo "$file" >> "${tmp_dir}/images.txt"
            echo "$hash" >> "${tmp_dir}/hash.txt"
            echo 1 > "${tmp_dir}/dirty"
            (( readc += 1 ))
        elif is_video "$file" \
            && [[ "$video_thumbnails" -eq 1 ]] \
            && command -v ffmpeg &> /dev/null
        then
            ! find_thumbnail && create_thumbnail
            echo "$file" >> "${tmp_dir}/image_names.txt"
            echo "$thumbnail_file" >> "${tmp_dir}/images.txt"
            echo "$hash" >> "${tmp_dir}/hash.txt"
            echo 1 > "${tmp_dir}/dirty"
            if [[ "$cache_thumbnails" -eq 1 ]] && \
                [[ ! "$thumbnail_file" == "$cache_name" ]]
            then
                cp -f "$thumbnail_file" "$cache_name"
            fi
            (( readc += 1 ))
        else
            touch "${cache_dir}/hash/other/${hash}"
        fi
        (( read_iter += 1 ))
        (( loadc += 1 ))
        echo "$read_iter" > "${tmp_dir}/read_iter"
    done
    echo 0 > "${tmp_dir}/read_lock"
}

######################################################################
# 2J                Clear entire screen
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
######################################################################
clear_screen() {
    printf "\e[2J\e[?25l\e[H"
}

######################################################################
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
# 2B                Move cursor down 2 lines
# 2K                Clear entire line
# 1J                Clear screen from cursor up
######################################################################
clearline() {
    printf "\e[?25l\e[H\e[B\e[2K\e[2;1H"
    status=
}

######################################################################
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
# 3B                Move cursor down 3 lines
# 2K                Clear entire line
# 0J                Clear screen from cursor down
######################################################################
clear_fileinfo() {
    # clear from 4th line and down
    printf "\e[?25l\e[H\e[3B\e[2K\e[0J\e[H"
}

show_cursor() {
    printf "\e[?25h"
}

######################################################################
# Starts the ueberzug daemon
######################################################################
start_daemon() {
    fifo="${tmp_dir}/fifo"
    rm -f "$fifo"
    mkfifo "$fifo"
    ueberzug layer --parse bash --silent < "$fifo" &
    exec {ueberzug}> "$fifo"
}

stop_daemon() {
    exec {ueberzug}>&-
    [[ "$exit_clear" == 1 ]] && clear_screen
    kill "$background_pid" &>/dev/null
    rm -rf "$tmp_dir"
    printf "\e[?25h"
    stty echo
}

######################################################################
# Calculates the parameters for the current view
######################################################################
calculate_dimensions() {
    local columns lines
    read -r lines columns < <(stty size)
    (( batch = optcurrent[gridcolumns] * optcurrent[gridlines] ))
    if [[ "${optcurrent[showfileinfo]}" == "showfileinfo" ]] && [[ "$batch" -gt 1 ]]
    then
        (( photo_columns = (columns - 2) / optcurrent[gridcolumns] ))
        (( photo_lines = (lines - 4) / optcurrent[gridlines] ))
    else
        (( photo_columns = columns / optcurrent[gridcolumns] ))
        (( photo_lines = (lines - 3) / optcurrent[gridlines] ))
    fi
    (( show = total - start ))
    [[ "$show" -gt "$batch" ]] && show="$batch"
    [[ "$current" -ge "$show" ]] && ((current = show - 1))
}

######################################################################
# Pads strings with fileinfo to fit into the given column width
######################################################################
pad_sides() {
    local leftpad p rightpad
    (( leftpad = $1 / 2 ))
    (( rightpad = $1 - leftpad ))
    for (( p = 0; p < leftpad; p++))
    do
        current_name=" $current_name"
    done
    for (( p = 0; p < rightpad; p++))
    do
        current_name+=" "
    done
}

######################################################################
# Draws the current batch of images on the screen
######################################################################
show_batch() {
    local counter draw_lines i index j posx posy
    [[ "$show" -lt 1 ]] && return
    if [[ "${optcurrent[showfileinfo]}" == "showfileinfo" ]] && [[ "$show" -gt 1 ]]
    then
        # Substracting 3 lines is a hack. The names can be printed in
        # two lines, but ueberzug is not exact in its drawing on the
        # terminal lines for different window sizes.
        # So I give it some more room for error.
        (( draw_lines = photo_lines - 3 ))
    else
        draw_lines="$photo_lines"
    fi

    for ((i = optcurrent[gridlines] * optcurrent[gridcolumns]; \
        i < previous_batch; i++))
    do
        assoc=([action]=remove [identifier]="ucollage$i")
        declare -p assoc > "$fifo"
    done
    for ((i = 0; i < optcurrent[gridlines]; i++ ))

    do
        for ((j = 0; j < optcurrent[gridcolumns]; j++))
        do
            ((counter = i * optcurrent[gridcolumns] + j))
            ((index = start + counter))
            if [[ "${optcurrent[showfileinfo]}" == "showfileinfo" ]] && \
                [[ "$batch" -gt 1 ]]
            then
                (( posx = 1 + j * photo_columns))
                (( posy = 4 + i * photo_lines))
            else
                (( posx = j * photo_columns))
                (( posy = 3 + i * photo_lines))
            fi
            assoc=([action]=add
                   [identifier]="ucollage$counter"
                   [path]="${images[$index]}"
                   [width]="$photo_columns"
                   [height]="$draw_lines"
                   [x]="$posx"
                   [y]="$posy"
                   [scaling_position_x]="$realscalingx"
                   [scaling_position_y]="$realscalingy"
                   [scaler]="${optcurrent[scaler]}")
            declare -p assoc > "$fifo"
        done
    done
    (( previous_batch = optcurrent[gridlines] * optcurrent[gridcolumns]))
}

######################################################################
# Modifies the parameters needed to show another batch
######################################################################
compute_batch() {
    local input="$1" read_iter
    if [[ -z "$input" ]]
    then
        input_autocomplete="batch"
        input_prompt="Batch # "
        get_input
    fi
    read -r read_iter < "${tmp_dir}/read_iter"
    case $input in
        next)
            # There exists an edge case here when $show is less that
            # $batch, but we are not in the last batch of images
            # This can happen when we are loading the images in the background
            # and the user has changes the batch size with the 's' option
            # right after starting up.
            if ((show < batch)) && ((start + show < total))
            then
                : # start stays the same and we just load the rest of the images
            elif (( start + show < total ))
            then
                (( start += show ))
            else
                warning="End of files"
                [[ "$read_iter" -lt "$argc" ]] && warning="End of loaded files"
            fi
            ;;
        last)
            (( new_start = total - ((total - 1) % batch + 1) ))
            if [[ "$new_start" -le "$start" ]]
            then
                warning="End of files"
                [[ "$read_iter" -lt "$argc" ]] && warning="End of loaded files"
            else
                start="$new_start"
            fi
            ;;
        previous)
            if [[ "$start" -eq 0 ]]
            then
                warning="Start of files"
            else
                (( start -= batch))
                # The below is useful in case of resizing
                # If I am in the second of batches of 10 and the
                # new window fits 20 then I don't want negative numbers
                [[ "$start" -lt 0 ]] && start=0
            fi
            ;;
        first)
            if [[ "$start" -eq 0 ]]
            then
                warning="Start of files"
            else
                start=0
            fi
            ;;
        *)
            [[ -n "$input" ]] && error="Unknown option: $input"
            ;;
    esac
    [[ -z "$warning" ]] && [[ -z "$error" ]] && redraw
    clear_sequence
}

######################################################################
# Calculates the next suggestion from the autocomplete array
######################################################################
set_suggestion() {
    # if suggestion count is 2 then that means that there is only one suggestion
    # that along with the input makes the count 2. In that case the suggestion
    # should be selected.
    [[ "$suggestion_count" -eq 2 ]] && suggestion="${autocomplete[1]}" && \
        clear_suggestions && return
    if [[ "$1" == "next" ]]
    then
        (( suggestion_index = (suggestion_index + 1) % suggestion_count ))
    elif [[ "$1" == "prev" ]]
    then
        (( suggestion_index = (suggestion_index - 1) % suggestion_count ))
    fi
    suggestion="${autocomplete[$suggestion_index]}"
}

######################################################################
# Saves the suggestion as input and clears everything related to autocomplete
######################################################################
clear_suggestions() {
    [[ -z "$suggestion" ]] && return
    input_left="$suggestion"
    suggestion=""
    suggestion_count=0
    unset autocomplete
}

clear_history() {
    if [[ -n "$input_history" ]]
    then
        input_left="$input_history"
        input_right=
        unset input_history
    fi
    [[ "$1" == "--force" ]] && cmd_history=()
}

######################################################################
# Escapes special characters in filenames in order to not have a problem
# with command execution. Should be used like var=$(escape_name "$var")
######################################################################
escape_name() {
    local -n name="$1"
    name="${name// /\\ }"
    name="${name//\(/\\\(}"
    name="${name//\)/\\\)}"
    name="${name//\{/\\\{}"
    name="${name//\}/\\\}}"
}

######################################################################
# Creates the automplete array based on the autocomplete type we want
######################################################################
create_suggestions() {
    local current_complete files=0 i last_word="" len merge=0 passed
    local subinput_autocomplete wordlist
    local -a autocomplete_level=() split_left=()
    autocomplete_level[0]="$input_autocomplete"
    if [[ "$input_autocomplete" == "ucollage" ]]
    then
            # this trick also determines the way i handle the prefix in
            # command mode i add a space after the parenthesis so that
            # the command is its own word
        input_left=${input_left/)*( )/) }
    fi
    IFS=" " read -r -a split_left <<< "$input_left"
    # we do that so that a space confirms a suggestion
    [[ "${input_left: -1}" == " " ]] && split_left+=("")
    [[ "${#split_left[@]}" -gt 0 ]] && last_word=${split_left[-1]}
    # The below 'for' loop creates the autocomplete level hierarchy
    # If the previous word cannot produce autocomplete we move one
    # back.
    for compword in ${split_left[*]}
    do
        [[ -z "${spacelist[$compword]}" ]] && \
            [[ -z "${sticklist[$compword]}" ]] && \
            continue
        current_complete="${autocomplete_level[-1]}"
        # a system command ends the level hierarchy with only the
        # addition of the 'file' autcomplete in the next 'for' loop
        [[ "$current_complete" =~ "!" ]] && break
        [[ "${spacelist[$current_complete]}" =~ $compword ]] || \
            [[ "${sticklist[$current_complete]}" =~ $compword ]] && \
            autocomplete_level+=("$compword")
    done

    for stick in "${!sticklist[@]}"
    do
        #The stick autocompletes are only for the ':set' command
        if [[ "$last_word" =~ ^$stick ]] && \
            [[ "${autocomplete_level[-1]}" == "set" ]]
        then
            split_left[-1]="$stick"
            split_left+=("${last_word#$stick}")
            autocomplete_level+=("$stick")
            last_word="${split_left[-1]}"
            merge=1
        fi
    done
    subinput_autocomplete="${autocomplete_level[-1]}"

    if [[ "$subinput_autocomplete" =~ ^(!|!%)$ ]]
    then
        passed=0 # this checks that I have already written a command
        for ((i = 0; i < ${#split_left[@]} - 1; i++))
        do
            command -v ${split_left[$i]} &>/dev/null && \
                [[ ${split_left[$i]} != "!" ]] && passed=1
        done
        [[ "$passed" -eq 1 ]] && subinput_autocomplete="file"
    fi

    case "$subinput_autocomplete" in
        "file")
            mapfile -t autocomplete < <(compgen -f "$last_word" | sort)
            files=1
            ;;
        *)
            wordlist="${spacelist[$subinput_autocomplete]}"
            wordlist+="${sticklist[$subinput_autocomplete]}"
            mapfile -t autocomplete < \
                <(IFS=" " compgen -W "$wordlist" "$last_word" | sort)
            ;;
    esac

    autocomplete=("$input_left" "${autocomplete[@]}")
    [[ "${#split_left[@]}" -gt 0 ]] && unset "split_left[-1]"
    i=1
    while [[ "$i" -lt ${#autocomplete[@]} ]]
    do
        if [[ "$files" -eq 1 ]] #only escape filenames
        then
            escape_name autocomplete[$i]
        fi

        len="${#split_left[@]}"
        if [[ "$len" -gt 0 ]]
        then
            if [[ "$merge" -eq 1 ]]
            then
                autocomplete[$i]="${split_left[*]}${autocomplete[$i]}"
            else
                autocomplete[$i]="${split_left[*]} ${autocomplete[$i]}"
            fi
        fi
        (( i += 1 ))
    done
    suggestion_index=0
    suggestion_count=${#autocomplete[@]}
    return 0
}

######################################################################
# Gets input from the user
######################################################################
get_input() {
    local available char cmd_history_index columns input_history key lines
    local move="" stop string suggestion suggestion_count suggestion_index
    local -a cmd_history=()
    read -r lines columns < <(stty size)
    available="$columns"
    clearline
    printf "\e[?25h%s\e7" "$input_prompt"
    ((available -= ${#input_prompt} + 1))
    while [[ "$exit_flag" -eq 0 ]]
    do
        printf "\e8\e[K"
        input_right="${input_right%%*( )}"
        [[ -n "$input_right" ]] && move="\e[${#input_right}D" || move=
        if [[ -n "$suggestion" ]]
        then
            string="$suggestion$input_right"
            [[ "${#string}" -gt "$available" ]] && string=${string: -${available}}
            printf "%s$move" "$string"
        elif [[ -n "$input_history" ]]
        then
            [[ "${#input_history}" -gt "$available" ]] && \
                input_history=${input_history: -${available}}
            printf "%s" "$input_history"
        else
            string="$input_left$input_right"
            [[ "${#string}" -gt "$available" ]] && string=${string: -${available}}
            printf "%s$move" "$string"
        fi
        key=
        char=
        while read -rsN1 -t 0.01 char &>/dev/null
        do
            key+="$char"
        done
        [[ -z "$key" ]] && continue
        case "$key" in
            $'\e[A') #up arrow press
                if [[ "$mode" == "command" ]]
                then
                    if [[ "${#cmd_history[@]}" -eq 0 ]]
                    then
                        mapfile -t cmd_history < \
                            <(grep "^${input_left}${input_right}" \
                            "$cache_dir/cmd_history" | uniq)
                        cmd_history_index=${#cmd_history[@]}
                    fi
                    ((cmd_history_index -= 1))
                    [[ "$cmd_history_index" -lt 0 ]] && cmd_history_index=0
                    input_history=${cmd_history[$cmd_history_index]}
                fi
                ;;
            $'\e[B') #down arrow press
                if [[ "$mode" == "command" ]]
                then
                    [[ "${#cmd_history[@]}" -eq 0 ]] && continue
                    ((cmd_history_index += 1))
                    [[ "$cmd_history_index" -gt ${#cmd_history[@]} ]] && \
                        cmd_history_index=${#cmd_history[@]}
                    input_history=${cmd_history[$cmd_history_index]}
                fi
                ;;
            $'\e[C') #right arrow press
                clear_suggestions
                clear_history
                if [[ -n "$input_right" ]]
                then
                    input_left="$input_left${input_right:0:1}"
                    input_right="${input_right:1}"
                fi
                ;;
            $'\e[D') #left arrow press
                clear_suggestions
                clear_history
                if [[ -n "$input_left" ]]
                then
                    input_right="${input_left: -1}$input_right"
                    input_left="${input_left:0:-1}"
                fi
                ;;
            $'\e[1;5C') #Ctrl + right arrow press
                # we have to stop at next non-alnum character
                clear_suggestions
                clear_history
                stop=${input_right##*([^[:alnum:]])*([[:alnum:]])}
                if [[ -z "$stop" ]]
                then
                    input_left+="$input_right"
                    input_right=
                else
                    input_left+="${input_right:0: -${#stop}}"
                    input_right=${input_right: -${#stop}}
                fi
                ;;
            $'\e[1;5D') #Ctrl + left arrow press
                # we have at the first alnum of the last alnum sequence
                clear_suggestions
                clear_history
                stop=${input_left%%*([[:alnum:]])*([^[:alnum:]])}
                input_right="${input_left:${#stop}}${input_right}"
                input_left="${stop}"
                ;;
            $'\e[H'|$'\e[1~') #Home
                clear_suggestions
                clear_history
                input_right="${input_left}${input_right}"
                input_left=""
                ;;
            $'\e[F'|$'\e[4~') #End
                clear_suggestions
                clear_history
                input_left+="${input_right}"
                input_right=""
                ;;
            $'\e[3~'|$'\e[P')
                clear_suggestions
                clear_history --force
                [[ -n "$input_right" ]] && input_right="${input_right:1}"
                ;;
            $'\e[2~')
                clear_suggestions
                clear_history --force
                input_left+="$(xclip -selection primary -o)"
                ;;
            $'')
                clear_suggestions
                clear_history --force
                input_left+="$(xclip -selection clipboard -o)"
                ;;
            $'\e')
                clear_suggestions
                clear_history --force
                input=
                break
                ;;
            $'\b'|$'\x7F'|$'')
                clear_suggestions
                clear_history --force
                [[ -n "$input_left" ]] && input_left="${input_left:0:-1}"
                ;;
            $'\n')
                clear_suggestions
                clear_history --force
                input="${input_left}${input_right}"
                break
                ;;
            [[:print:]])
                clear_suggestions
                clear_history --force
                input_left+="$key"
                ;;
            $'')
                clear_suggestions
                clear_history
                input_left=
                ;;
            $'')
                clear_suggestions
                clear_history
                stop=${input_left%%?(*([[:alnum:]])*([[:space:]])|*([^[:alnum:]]))}
                input_left="${stop}"
                ;;
            $'\t')
                [[ -z "$input_autocomplete" ]] && continue
                [[ ${#autocomplete[@]} -gt 0 ]] && set_suggestion next && continue
                ! create_suggestions && continue || set_suggestion next
                ;;
            $'\e[Z')
                [[ -z "$input_autocomplete" ]] && continue
                [[ ${#autocomplete[@]} -gt 0 ]] && set_suggestion prev && continue
                ! create_suggestions && continue || set_suggestion prev
                ;;
            *)
                ;;
        esac
    done
    input_left=
    input_right=
    input_autocomplete=
    trim_spaces input
    clearline
    [[ -z "$input" ]] && return 1 || return 0
}

is_natural() {
    [[ "$1" =~ ^([1-9][0-9]*|0+[1-9][0-9]*)$ ]]
}

######################################################################
# Draws filenames under the images on the screen
######################################################################
print_names() {
    local columns i lines
    read -r lines columns < <(stty size)
    for ((i = 4; i <= lines; i++))
    do
        printf "\e[B\e[%s;1H" "$i"
        # not using %s because I want to parse the escape characters
        printf "${line_names[$((i - 4))]}"
    done
}

set_stars() {
    local -n str="$1"
    local hash="${filehash[$index]}" index="$2" k rating=""
    str=
    if is_image
    then
        eval "$(cat "${cache_dir}/hash/images/$hash")"
    elif is_video
    then
        eval "$(cat "${cache_dir}/hash/videos/$hash")"
    fi
    if [[ -n "$rating" ]]
    then
        for ((k = 0; k < rating; k++))
        do
            str+="★"
        done
        for ((k = rating; k < 5; k++))
        do
            str+="☆"
        done
    fi
}

######################################################################
# Update the fileinfo to account for batch changes, file renaming or rating
######################################################################
update_fileinfo() {
    [[ "${optcurrent[showfileinfo]}" == "noshowfileinfo" ]] || \
        [[ "$batch" -eq 1 ]] && \
        clear_fileinfo && return
    local cnt columns current_in_line current_name i j linelength lines
    local namelength row stars total_lines
    local -a line_names=()
    read -r lines columns < <(stty size)

    (( total_lines = (show - 1) / optcurrent[gridcolumns] + 1))
    line_names[0]="┌"
    line_names[$((total_lines * photo_lines))]="└"
    for ((j = 1; j < columns - 1; j++))
    do
        line_names[0]+="─"
        line_names[$((total_lines * photo_lines))]+="─"
    done
    line_names[0]+="┐"
    line_names[$((total_lines * photo_lines))]+="┘"

    cnt=0
    for ((i = 1; i < total_lines * photo_lines; i++))
    do
        current_in_line=0
        if ((i % photo_lines == 0))
        then
            line_names[$i]="├"
            for ((j = 1; j < columns - 1; j++))
            do
                line_names[$i]+="─"
            done
            line_names[$i]+="┤"
        elif ((i % photo_lines ==  photo_lines - 1))
        then
            line_names[$i]="│"
            ((row = (i - 1) / photo_lines))
            for ((j = 0; j < optcurrent[gridcolumns]; j++, cnt++))
            do
                (( index = start + row * optcurrent[gridcolumns] + j))
                if [[ "$cnt" -lt "$show" ]]
                then
                    current_name="$((index + 1 - start)): "
                    case "${optcurrent[fileinfo]}" in
                        "ratings")
                            set_stars stars "$index"
                            current_name+="$stars"
                            ;;
                        "names")
                            current_name+="$(basename "${image_names[$index]}")"
                            [[ -n ${edits[$index]} ]] && \
                                current_name="~ ${current_name}"
                            [[ -n ${tags[$index]} ]] && \
                                current_name="* ${current_name}"
                            ;;
                    esac
                    (( max_length = photo_columns - 2 ))
                    current_name=${current_name:0:$max_length}
                    namelength="${#current_name}"
                    if (( index - start == current))
                    then
                        current_name="\e[7m$current_name\e[m"
                        current_in_line=1
                    fi
                    pad_sides $((photo_columns - namelength))
                    line_names[$i]+="$current_name"
                fi
            done
            linelength=${#line_names[$i]}
            # substract the inversion escape chars
            [[ "$current_in_line" -eq 1 ]] && ((linelength -= 9))
            for ((j = linelength; j < columns - 1; j++))
            do
                line_names[$i]+=" "
            done
            line_names[$i]+="│"
        else
            line_names[$i]="│"
            for ((j = 1; j < columns - 1; j++))
            do
                line_names[$i]+=" "
            done
            line_names[$i]+="│"

        fi
    done

    for ((i = total_lines * photo_lines + 1; i < lines - 3; i++))
    do
        line_names[$i]=
        for ((j = 0; j < columns; j++))
        do
            line_names[$i]+=" "
        done
    done
    print_names
}

redraw() {
    calculate_dimensions
    show_batch
    update_fileinfo
}

######################################################################
# Set information relating to the current view
######################################################################
set_info() {
    local begin lines columns photo_name stars finish tlen elen sel_info=
    local length padding
    read -r lines columns < <(stty size)
    read -r read_iter < "${tmp_dir}/read_iter"
    ((begin = start + 1))
    info=" ${optcurrent[gridlines]} x ${optcurrent[gridcolumns]}"
    info_total="$total"
    ((read_iter < argc)) && info_total+=" ($((argc - read_iter)) unloaded)"
    if in_monocle
    then
        photo_name=$(basename "${image_names[$start]}")
        [[ -n ${edits[$start]} ]] && photo_name="~ ${photo_name}"
        [[ -n ${tags[$start]} ]] && photo_name="* ${photo_name}"
        info+=" │ $begin/$info_total │ ${photo_name}"
        set_stars stars "$start"
        [[ -n "$stars" ]] && info+=" | $stars"
    else
        ((finish = begin + show - 1))
        info+=" │ [$begin-$finish]/$info_total"
    fi
    tlen=${#tags[@]}
    elen=${#edits[@]}
    [[ "$tlen" -gt 0 ]] && info+=" │ * ${tlen}"
    [[ "$elen" -gt 0 ]] && info+=" │ ~ ${elen}"
    [[ "${optcurrent[showfileinfo]}" == "noshowfileinfo" ]] && ! in_monocle && \
        sel_info=" | ∙ $((current + 1)) "
    length=${#info}
    ((length += ${#sel_info}))
    (( padding = columns - length))
    for ((i = 0; i < padding; i++))
    do
        info+=" "
    done
    info+="$sel_info"
}

######################################################################
# Checks whether we are in monocle mode
######################################################################
in_monocle() {
    [[ "$batch" -eq 1 ]] && return 0 || return 1
}

######################################################################
# Evaluate a command
######################################################################
eval_cmd() {
    local ans="" columns lines
    read -r lines columns < <(stty size)
    if [[ "${optcurrent[execprompt]}" == "execprompt" ]]
    then
        clearline
        cmd_prompt+="? (Press y/Y/Enter to confirm)"
        cmd_prompt=${cmd_prompt:0:$columns}
        printf "%s" "$cmd_prompt"
        while [[ -z "$ans" ]] && [[ "$exit_flag" -eq 0 ]]
        do
            read -rsN1 -t 0.01 ans &>/dev/null
        done
        clearline
        [[ ! "$ans" =~ ^(y|Y|$'\n')$ ]] && return 1
    fi
    error=$(eval "$cmd" 2>&1 >/dev/null)
    [[ -z "$error" ]] && return 0 || return 1
}

######################################################################
# Checks if all indices given as input are valid
######################################################################
valid_indices() {
    local i
    for (( i = 0; i < index_count; i++ ))
    do
        if ! is_natural ${image_index[i]}
        then
            error="NaN: ${image_index[$i]}" && return 1
        elif (( image_index[i] <= 0 || image_index[i] > show ))
        then
            error="Index out of bounds: ${image_index[$i]}" && return 1

        fi
    done
    return 0
}

######################################################################
# Selects all indices given the scope
######################################################################
all_indices() {
    image_index=()
    local i
    if [[ "$1" == "--global" ]]
    then
        for ((i = 1; i <= total; i++ ))
        do
            image_index+=("$i")
        done
    else
        for ((i = 1; i <= show; i++ ))
        do
            image_index+=("$i")
        done
    fi
}

######################################################################
# Set the image_index to operate on (array of indices)
######################################################################
get_image_index() {
    unset image_index
    local i star=0
    [[ "$prefix" == "#" ]] && prefix="$repeat_prefix"
    if [[ "$prefix" == ";" ]]
    then
        for (( i = 1; i <= total; i++ ))
        do
            # indices start from 0 in tag array
            [[ -n ${tags[$((i - 1))]} ]] && image_index+=("$i")
        done
        [[ "${#image_index[@]}" -eq 0 ]] && \
            warning="No tagged images" && return 1
    elif [[ "$prefix" =~ ^\*\* ]]
    then
        all_indices --global
        star=2
    elif [[ "$prefix" =~ ^\* ]]
    then
        all_indices --local
        star=1
    elif [[ -n "$prefix" ]]
    then
        IFS=" " read -r -a image_index <<< "$prefix"
        index_count=${#image_index[@]}
        ! valid_indices && return 1
    # no prefix given
    elif [[ "$batch" -eq 1 ]] # no-prefix, just the key pressed
    then
        image_index[0]=1
    else
        image_index[0]="$((current + 1))"
    fi

    index_count=${#image_index[@]}
    [[ "$index_count" -eq 0 ]] && return 1

    for (( i = 0; i < index_count; i++ ))
    do
        (( image_index[i] -= 1 )) #adjust index for arrays
    done
    if [[ "$star" -lt 2 ]] ## if ** is used then the indices are correct
    then
        for (( i = 0; i < index_count; i++ ))
        do
            (( image_index[i] += start))
        done
    fi
    return 0
}

######################################################################
# Checks whether the provided index is local to the current view
######################################################################
is_index_local() {
    local end
    (( end = start + show ))
    [[ "$1" -ge "$start" ]] && [[ "$1" -lt "$end" ]] && return 0 || return 1
}


######################################################################
# Checks whether the provided index corresponds to an image and not
# another filetype, thus image_names and images need to be updated
# together
######################################################################
parallel_update() {
    [[ "${image_names[$1]}" == "${images[$1]}" ]] && return 0 || return 1
}

######################################################################
# Update the status line
######################################################################
update_status() {
    local columns length lines new_status prefix_status
    local -a line=()
    printf "\e[?25l"
    read -r lines columns < <(stty size)
    set_info
    info=${info:0:$columns}
    line[0]="\e[H\e[107;30m${info}\e[m\n"

    if [[ -n "$success" ]]
    then
        length="${#success}"
        line[1]="\e[32m${success:0:$((columns - 25))}\e[m"
    elif [[ -n "$error" ]]
    then
        line[1]="\e[31m${error:0:$((columns - 25))}\e[m"
        length="${#error}"
    elif [[ -n "$warning" ]]
    then
        line[1]="\e[33m${warning:0:$((columns - 25))}\e[m"
        length="${#warning}"
    elif [[ -n "$message" ]]
    then
        line[1]="${message:0:$((columns - 25))}"
        length="${#message}"
    fi
    for ((i = length; i < columns-20; i++))
    do
        line[1]+=" "
    done

    if [[ -n "$prefix" ]] && [[ -n "$mapping" ]]
    then
        prefix_status="($prefix)$mapping"
    elif [[ -n "$mapping" ]]
    then
        prefix_status="$mapping"
    elif [[ -n "$prefix" ]]
    then
        prefix_status="($prefix)"
    else
        prefix_status=
    fi
    [[ ${#prefix_status} -gt 15 ]] && prefix_status=${prefix_status: -15}

    for ((i = ${#prefix_status}; i < 20; i++))
    do
        prefix_status+=" "
    done
    line[1]+="\e[2;1H\e[$((columns - 20))C${prefix_status}"
    
    new_status="${line[0]}${line[1]}"
    if [[ "$new_status" != "$status" ]]
    then
        printf "\e[H$new_status"
        success=
        error=
        warning=
        message=
    fi
}

run_use_script() {
    local script="$1" cmd_prompt_base="$2"
    local cmd cmd_prompt executed=0 ind sc_i
    if get_image_index
    then
        for (( sc_i = 0; sc_i < index_count; sc_i++))
        do
            ind=${image_index[$sc_i]}
            cmd="${script//%in%/\"${image_names[$ind]}\"}"
            cmd_prompt="${cmd_prompt_base}: "
            cmd_prompt+="\"$(basename -a "${image_names[$ind]}" | \
                tr '\n' ' ' | head -c-1)\""
            eval_cmd && ((executed += 1))
        done
        if [[ "$executed" -eq 0 ]]
        then
            error="No executions"
        elif [[ "$executed" -lt "$index_count" ]]
        then
            warning="Executed: $executed of $index_count"
        else
            success="Success"
        fi
    fi
    clear_sequence --repeat
}

run_edit_script() {
    local script="$1"
    local cmd edited=0 file hash ind level non_image=0
    local old_exec_prompt="${optcurrent[execprompt]}" sc_i tmpfile
    optcurrent[execprompt]="noexecprompt"
    if get_image_index
    then
        for (( sc_i = 0; sc_i < index_count; sc_i++))
        do
            ind=${image_index[$sc_i]}
            level=${edits[$ind]}
            file="${image_names[$ind]}"
            case $file in
                (*.*) extension=${file##*.};;
                (*)   extension="";;
            esac
            hash="${filehash[$ind]}"
            ! is_image && ((non_image += 1)) && continue
            tmpfile="${tmp_dir}/${hash}.$((level + 1)).${extension}"
            cmd=${script//%in%/\"${images[$ind]}\"}
            cmd=${cmd//%out%/\"${tmpfile}\"}
            if eval_cmd
            then
                ((edited += 1))
                ((edits[ind] += 1))
                images[$ind]="$tmpfile"
                # now delete the other branch of the history if it exists
                ((level += 2))
                while [[ -f "${tmp_dir}/${hash}.$((level)).${extension}" ]]
                do
                    rm "${tmp_dir}/${hash}.$((level)).${extension}"
                    ((level += 1))
                done
                redraw
            fi
        done
        if [[ "$non_image" -eq "$index_count" ]]
        then
            error="Editing supported only for images"
        else
            if [[ "$edited" -eq 0 ]]
            then
                error="No images edited"
            elif [[ "$edited" -lt "$index_count" ]]
            then
                warning="Edited: $edited of $index_count"
            else
                success="Success"
            fi
        fi
    fi
    optcurrent[execprompt]="$old_exec_prompt"
    clear_sequence --repeat
}

_write() {
    local cmd cmd_prompt hash ind local_changes=0 no_pending=0 saved=0
    local se_i tmpfile
    if get_image_index
    then
        for (( se_i = 0; se_i < index_count; se_i++))
        do
            ind=${image_index[$se_i]}
            tmpfile=${images[$ind]}
            case $tmpfile in
                (*.*) extension=${tmpfile##*.};;
                (*)   extension="";;
            esac
            hash=${tmpfile%.*([[:digit:]]).${extension}}
            hash=${hash#${tmp_dir}/}
            [[ -z ${edits[$ind]} ]] && ((no_pending += 1)) && continue
            cmd="cp -f \"${tmpfile}\" \"${image_names[$ind]}\""
            cmd_prompt="Save edits for ${image_names[$ind]}"
            if eval_cmd
            then
                ((saved += 1))
                images[$ind]="${image_names[$ind]}"
                rm "${tmp_dir}/$hash".* # delete all history
                unset edits["$ind"]
                read -rd ' ' hash < \
                    <(head -c 100000 "${image_names[$ind]}" 2>/dev/null | xxh128sum)
                filehash[$ind]="$hash"
                is_index_local "$ind" && local_changes=1
            fi
        done

        if [[ "$no_pending" -eq "$index_count" ]]
        then
            error="Nothing to save"
        else
            if [[ "$saved" -eq 0 ]]
            then
                error="No images saved"
            elif [[ "$saved" -lt "$index_count" ]]
            then
                warning="Saved: $saved of $index_count"
                [[ "$local_changes" -eq 1 ]] && update_fileinfo
            else
                success="Done"
                [[ "$local_changes" -eq 1 ]] && update_fileinfo
            fi
        fi
    fi
    clear_sequence --repeat
}

_rate() {
    local file hash ind input_autocomplete input_prompt mi rating
    local rating_arr update=0
    if get_image_index
    then
        if [[ -n "$*" ]]
        then
            IFS=" " read -r -a rating_arr <<< "$*"
            for ((i = ${#rating_arr[@]}; i < index_count; i++))
            do
                rating_arr[$i]=${rating_arr[-1]}
            done
        fi

        for (( mi = 0; mi < index_count; mi++))
        do
            ind=${image_index[$mi]}
            if [[ -n "${rating_arr[$mi]}" ]]
            then
                input="${rating_arr[$mi]}"
            else
                input_prompt="Rating for [$((ind % batch + 1))]: "
                input_autocomplete="rating"
                ! get_input && continue
                trim_spaces input --force
            fi
            if [[ "$input" =~ ^(0|1|2|3|4|5)$ ]]
            then
                hash="${filehash[$ind]}"
                rating=
                file=
                if is_image
                then
                    file="${cache_dir}/hash/images/$hash"
                elif is_video
                then
                    file="${cache_dir}/hash/videos/$hash"
                fi
                eval "$(cat "$file")"
                if [[ -n "$rating" ]]
                then
                    sed -i "s/rating=./rating=${input}/" \
                        "${cache_dir}/hash/images/$hash"
                else
                    echo "rating=$input" >> "${cache_dir}/hash/images/$hash"
                fi
                is_index_local "$ind" && update=1
            else
                error="Rating has to be in [0-5]"
            fi
        done
        [[ "$update" -eq 1 ]] && [[ "${optcurrent[fileinfo]}" == "ratings" ]] && \
            update_fileinfo
    fi
    clear_sequence --repeat
}

_execute() {
    local args="" base cmd cmd_prompt edit_args="" ex_i executed=0 input
    local input_autocomplete input_prompt nice ind nicer_args=""
    if [[ "$1" == "image" ]] # each image on its own
    then
        if get_image_index
        then
            for (( ex_i = 0; ex_i < index_count; ex_i++))
            do
                ind=${image_index[$ex_i]}
                input_prompt="Command for [$((ind % batch + 1))]: "
                input_autocomplete="!"
                ! get_input && continue
                cmd=${input//%s/\"${image_names[$ind]}\"}
                base=$(basename "${image_names[$ind]}")
                nice=${input//%s/\"$base\"}
                cmd=${cmd//%e/\"${images[$ind]}\"}
                nice=${nice//%e/<edited_file>}
                cmd_prompt="$ ${nice}"
                eval_cmd && ((executed += 1))
            done
        fi
    elif [[ "$1" == "same" ]]
    then
        # shift in order to take the rest of the arguments as the command
        # to be executed
        shift
        execute_cmd="$*"
        if get_image_index
        then
            if [[ -n "$execute_cmd" ]]
            then
                input="$execute_cmd"
            else
                input_prompt="Command: "
                input_autocomplete="!"
                get_input
            fi
            if [[ -n "$input" ]]
            then
                for (( ex_i = 0; ex_i < index_count; ex_i++))
                do
                    ind=${image_index[$ex_i]}
                    cmd=${input//%s/\"${image_names[$ind]}\"}
                    base=$(basename "${image_names[$ind]}")
                    nice=${input//%s/\"$base\"}
                    cmd=${cmd//%e/\"${images[$ind]}\"}
                    nice=${nice//%e/<edited_file>}
                    cmd_prompt="$ ${nice}"
                    eval_cmd && ((executed += 1))
                done
            fi
        fi
    else # bundle images
        if get_image_index
        then
            for (( i = 0; i < index_count; i++))
            do
                ind=${image_index[$i]}
                args+="\"${image_names[$ind]}\" "
                edit_args+="\"${images[$ind]}\" "
                nicer_args+="\"$(basename "${image_names[$ind]}")\" "
            done
            shift
            execute_cmd="$*"
            if [[ -n "$execute_cmd" ]]
            then
                input="$execute_cmd"
            else
                input_prompt="Command: "
                input_autocomplete="!"
                get_input
            fi
            if [[ -n "$input" ]]
            then
                cmd=${input//%S/$args}
                nice=${input//%S/$nicer_args}
                cmd=${cmd//%E/$edit_args}
                nice=${nice//%E/<edited files>}
                cmd_prompt="$ ${nice}"
                eval_cmd && ((executed += index_count))
            fi
        fi
    fi
    if [[ "$executed" -eq 0 ]]
    then
        error="No executions"
    elif [[ "$executed" -lt "$index_count" ]]
    then
        warning="Executed: $executed of $index_count"
    else
        success="Success"
    fi
    clear_sequence --repeat
    execute_cmd=
}

_rename() {
    local update=0 mv_i ind input input_prompt input_autocomplete pathto
    local cmd cmd_prompt
    if get_image_index
    then
        local renamed=0
        for (( mv_i = 0; mv_i < index_count; mv_i++))
        do
            ind=${image_index[$mv_i]}
            input=
            input_prompt="New name for [$((ind % batch + 1))]: "
            input_left="$(basename "${image_names[$ind]}")"
            pathto="$(dirname "${image_names[$ind]}")"
            [[ "$index_count" -eq 1 ]] && input="$1"
            if [[ -z "$input" ]]
            then
                ! get_input && continue
            fi
            cmd="mv \"${image_names[$ind]}\" \"$pathto/$input\""
            cmd_prompt="Rename [$((ind % batch + 1))] to: ${input}"
            if eval_cmd
            then
                ((renamed += 1))
                # in case of video or edited images we only update the name
                parallel_update "$ind" && images[$ind]="$input"
                image_names[$ind]="$input"
                is_index_local "$ind" && update=1
            fi
        done
        if [[ "$renamed" -eq 0 ]]
        then
            error="No renames"
        elif [[ "$renamed" -lt "$index_count" ]]
        then
            warning="Renamed: $renamed of $index_count"
        else
            success="Success"
        fi
        [[ "$update" -eq 1 ]] && [[ "${optcurrent[fileinfo]}" == "names" ]] && \
            update_fileinfo
    fi
    clear_sequence --repeat
}

_goto() {
    [[ "$prefix" =~ ^(;|\*+)$ ]] && prefix=
    if get_image_index
    then
        if [[ "$batch" -gt 1 ]]
        then
            wide_vertical=${optcurrent[gridlines]}
            wide_horizontal=${optcurrent[gridcolumns]}
        fi
        start="$image_index"
        optcurrent[gridlines]=1
        optcurrent[gridcolumns]=1
        redraw
    fi
    clear_sequence
}

_delete() {
    local cmd cmd_prompt del_i deleted=0 ind update=0
    if get_image_index
    then
        for (( del_i = 0; del_i < index_count; del_i++))
        do
            # adjust index because we trim the arrays after deleting
            (( updated = del_i - deleted ))
            ind=${image_index[$updated]}
            cmd="mv \"${image_names[$ind]}\" \"$trash_dir\""
            cmd_prompt="Delete: $(basename "${image_names[$ind]}")"
            if eval_cmd
            then
                unset image_names["${image_index[$updated]}"]
                unset images["${image_index[$updated]}"]
                image_names=("${image_names[@]}")
                images=("${images[@]}")
                total=${#images[@]}
                is_index_local "$ind" && update=1
                (( deleted += 1 ))
            fi
        done
        if [[ "$deleted" -eq 0 ]]
        then
            error="No deletions"
        elif [[ "$deleted" -lt "$index_count" ]]
        then
            warning="Deleted: $deleted of $index_count"
        else
            success="Success"
        fi
        [[ "$update" -eq 1 ]] && redraw
    fi
    clear_sequence --repeat
}

_tag() {
    local i update=0
    case $1 in
        tag)
            if get_image_index
            then
                for (( i = 0; i < index_count; i++))
                do
                    [[ -z ${tags[${image_index[$i]}]} ]] && \
                        tags[${image_index[$i]}]=1 && \
                        is_index_local "${image_index[$i]}" && update=1
                done
            fi
            ;;
        untag)
            if get_image_index
            then
                for (( i = 0; i < index_count; i++))
                do
                    [[ -n ${tags[${image_index[$i]}]} ]] && \
                        unset tags["${image_index[$i]}"] && \
                        is_index_local "${image_index[$i]}" && update=1
                done
            fi
            ;;
    esac
    [[ "$update" -eq 1 ]] && update_fileinfo
    clear_sequence --repeat
}

edit_history() {
    local file hash ind level old_exec_prompt="${optcurrent[execprompt]}"
    local redo_i redone=0 tmpfile undo_i undone=0
    optcurrent[execprompt]="noexecprompt"
    if [[ "$1" == "--undo" ]]
    then
        if get_image_index
        then
            for (( undo_i = 0; undo_i < index_count; undo_i++))
            do
                ind=${image_index[$undo_i]}
                level=${edits[$ind]:-0}
                [[ "$level" -eq 0 ]] && continue
                file="${image_names[$ind]}"
                case $file in
                    (*.*) extension=${file##*.};;
                    (*)   extension="";;
                esac
                hash="${filehash[$ind]}"
                if [[ "$level" -eq 1 ]]
                then
                    tmpfile="$file"
                else
                    tmpfile="${tmp_dir}/${hash}.$((level - 1)).${extension}"
                fi
                ((undone += 1))
                ((edits[ind] -= 1))
                #unset if at start of history
                ((edits[ind] == 0)) && unset edits["$ind"]
                images[$ind]="$tmpfile"
                redraw
            done
            if [[ "$undone" -eq 0 ]]
            then
                error="Already at oldest change"
            elif [[ "$undone" -lt "$index_count" ]]
            then
                warning="Undone: $undone of $index_count"
            else
                success="Success"
            fi
        fi
    elif [[ "$1" == "--redo" ]]
    then
        if get_image_index
        then
            for (( redo_i = 0; redo_i < index_count; redo_i++))
            do
                ind=${image_index[$redo_i]}
                level=${edits[$ind]:-0}
                file="${image_names[$ind]}"
                case $file in
                    (*.*) extension=${file##*.};;
                    (*)   extension="";;
                esac
                hash="${filehash[$ind]}"
                tmpfile="${tmp_dir}/${hash}.$((level + 1)).${extension}"
                [[ ! -f "$tmpfile" ]] && continue
                ((redone += 1))
                ((edits[ind] += 1))
                images[$ind]="$tmpfile"
                redraw
            done
            if [[ "$redone" -eq 0 ]]
            then
                error="Already at newest change"
            elif [[ "$redone" -lt "$index_count" ]]
            then
                warning="Redone: $redone of $index_count"
            else
                success="Success"
            fi
        fi
    fi
    optcurrent[execprompt]="$old_exec_prompt"
    clear_sequence --repeat
}

update_reverse(){
    if [[ "$dirty" -eq 0 ]]
    then
        reverse_images
        start=0
        redraw
    else # we have not read all images so we need to go from the start
        break_flag=1
    fi
}

reverse_images(){
    local max min=0 temp
    (( max = ${#images[@]} -1 ))
    while [[ min -lt max ]]
    do
        temp="${image_names[$min]}"
        image_names[$min]="${image_names[$max]}"
        image_names[$max]="$temp"

        temp="${images[$min]}"
        images[$min]="${images[$max]}"
        images[$max]="$temp"

        (( min += 1 ))
        (( max -= 1 ))
    done
}

set_scaling() {
    if [[ "${optcurrent[scalingx]}" -lt 0 ]]
    then
        optcurrent[scalingx]=0
    elif [[ "${optcurrent[scalingx]}" -gt 100 ]]
    then
        optcurrent[scalingx]=100
    fi
    if [[ "${optcurrent[scalingy]}" -lt 0 ]]
    then
        optcurrent[scalingy]=0
    elif [[ "${optcurrent[scalingy]}" -gt 100 ]]
    then
        optcurrent[scalingy]=100
    fi
    read -r realscalingx < <(bc -l <<< "scale=2; ${optcurrent[scalingx]} / 100")
    read -r realscalingy < <(bc -l <<< "scale=2; ${optcurrent[scalingy]} / 100")
}

_set() {
    split() {
        local -n arr="$1"
        IFS=$'\n' read -rd "" -ra arr <<< "${2/$3/$'\n'}"
    }
    local args oldvalue option prefix_args prefix_count=0 settings="$*"
    local type value
    # Giving prefixes overrides command line numbers
    split prefix_args "$prefix" " "
    if [[ "$settings" =~ all@ ]]
    then
        settings="${!optdefault[*]}@"
        settings=${settings// /@ }
    fi
    eval_cmd=
    message=
    for setting in $settings
    do
        case $setting in
            *"+="*)
                split args "$setting" "+="
                option="${args[0]}"
                type="+="
                value="${args[1]}"
                if [[ -n "${prefix_args[$prefix_count]}" ]]
                then
                    value="${prefix_args[$prefix_count]}"
                    ((prefix_count < ${#prefix_args[@]} - 1)) && \
                        ((prefix_count += 1))
                fi
                ;;
            *"-="*)
                split args "$setting" "-="
                option="${args[0]}"
                type="-="
                value="${args[1]}"
                if [[ -n "${prefix_args[$prefix_count]}" ]]
                then
                    value="${prefix_args[$prefix_count]}"
                    ((prefix_count < ${#prefix_args[@]} - 1)) && \
                        ((prefix_count += 1))
                fi
                ;;
            *"^="*)
                split args "$setting" "^="
                option="${args[0]}"
                type="^="
                value="${args[1]}"
                if [[ -n "${prefix_args[$prefix_count]}" ]]
                then
                    value="${prefix_args[$prefix_count]}"
                    ((prefix_count < ${#prefix_args[@]} - 1)) && \
                        ((prefix_count += 1))
                fi
                ;;
            *"="*)
                split args "$setting" "="
                option="${args[0]}"
                type="="
                value="${args[1]}"
                if [[ -n "${prefix_args[$prefix_count]}" ]]
                then
                    value="${prefix_args[$prefix_count]}"
                    ((prefix_count < ${#prefix_args[@]} - 1)) && \
                        ((prefix_count += 1))
                fi
                ;;
            *":"*)
                split args "$setting" ":"
                option="${args[0]}"
                type="="
                value="${args[1]}"
                if [[ -n "${prefix_args[$prefix_count]}" ]]
                then
                    value="${prefix_args[$prefix_count]}"
                    ((prefix_count < ${#prefix_args[@]} - 1)) && \
                        ((prefix_count += 1))
                fi
                ;;
            *"?")
                option="${setting%?}"
                type="ask"
                value=
                ;;
            "no"*)
                option="${setting#no}"
                type="off"
                value=
                ;;
            "inv"*)
                option="${setting#inv}"
                type="inv"
                value=
                ;;
            *"!")
                option="${setting%!}"
                type="inv"
                value=
                ;;
            *"@")
                option="${setting%@}"
                type="def"
                value=
                ;;
            *)
                option="$setting"
                type="on"
                value=
                ;;
        esac
        oldvalue="${optcurrent[$option]}"
        case "$type" in
            "+=")
                [[ -z "$value" ]] && continue
                case ${optiontype[$option]} in
                    "number")
                        if is_natural "$value" || [[ "$value" -eq 0 ]]
                        then
                            ((optcurrent[$option] += value))
                        else
                            message+="\e[41m\e[30mNumber required after =: "
                            message+="$setting\e[m "
                        fi
                        ;;
                    "string")
                        optcurrent[$option]+="$value"
                        ;;
                    "enum"|"boolean")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "-=")
                [[ -z "$value" ]] && continue
                case ${optiontype[$option]} in
                    "number")
                        if is_natural "$value" || [[ "$value" -eq 0 ]]
                        then
                            ((optcurrent[$option] -= value))
                        else
                            message+="\e[41m\e[30mNumber required after =: "
                            message+="$setting\e[m "
                        fi
                        ;;
                    "string")
                        optcurrent[$option]=${optcurrent[$option]//"$value"}
                        ;;
                    "enum"|"boolean")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "^=")
                [[ -z "$value" ]] && continue
                case ${optiontype[$option]} in
                    "number")
                        if is_natural "$value" || [[ "$value" -eq 0 ]]
                        then
                            ((optcurrent[$option] *= value))
                        else
                            message+="\e[41m\e[30mNumber required after =: "
                            message+="$setting\e[m "
                        fi
                        ;;
                    "string")
                        optcurrent[$option]="${value}${optcurrent[$option]}"
                        ;;
                    "enum"|"boolean")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "=")
                [[ -z "$value" ]] && continue
                case ${optiontype[$option]} in
                    "number")
                        if is_natural "$value" || [[ "$value" -eq 0 ]]
                        then
                            ((optcurrent[$option] = value))
                        else
                            message+="\e[41m\e[30mNumber required after =: "
                            message+="$setting\e[m "
                        fi
                        ;;
                    "string")
                        optcurrent[$option]="${value}"
                        ;;
                    "enum")
                        if [[ "$value" =~ ^(${enumoptvalue[$option]// /|})$ ]]
                        then
                            optcurrent[$option]="${value}"
                        else
                            message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        fi
                        ;;
                    "boolean")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "ask")
                if [[ -n "${optcurrent[$option]}" ]]
                then
                    case ${optiontype[$option]} in
                        "number"|"string"|"enum")
                            message+="${option}=${optcurrent[$option]} "
                            ;;
                        "boolean")
                            message+="${optcurrent[$option]} "
                            ;;
                    esac
                else
                    message+="\e[41m\e[30mUnknown option: $setting\e[m "
                fi
                ;;
            "off")
                case ${optiontype[$option]} in
                    "number"|"string"|"enum")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    "boolean")
                        optcurrent[$option]="$setting"
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "inv")
                case ${optiontype[$option]} in
                    "number"|"string"|"enum")
                        message+="\e[41m\e[30mInvalid argument: $setting\e[m "
                        ;;
                    "boolean")
                        if [[ "${optcurrent[$option]}" == "no$option" ]]
                        then
                            optcurrent[$option]="$option"
                        else
                            optcurrent[$option]="no$option"
                        fi
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
            "def")
                if [[ -n "${optdefault[$option]}" ]]
                then
                    optcurrent[$option]="${optdefault[$option]}"
                else
                    message+="\e[41m\e[30mUnknown option: $setting\e[m "
                fi
                ;;
            "on")
                case ${optiontype[$option]} in
                    "number"|"string"|"enum")
                        message+="${option}=${optcurrent[$option]} "
                        ;;
                    "boolean")
                        optcurrent[$option]="$setting"
                        ;;
                    *)
                        message+="\e[41m\e[30mUnknown option: $setting\e[m "
                        ;;
                esac
                ;;
        esac
        if [[ "${optcurrent[$option]}" != "$oldvalue" ]]
        then
            eval "${optupdate[$option]}"
        fi
    done
    clear_sequence
}

_select() {
    [[ "$prefix" =~ ^(;|\*+)$ ]] && prefix=
    [[ -z "$prefix" ]] && prefix="1"
    local limit prefix_args
    IFS=" " read -r -a prefix_args <<< "$prefix"
    case "$1" in
        left)
            ((limit = (current / optcurrent[gridcolumns])))
            ((limit *= optcurrent[gridcolumns]))
            ((current -= prefix_args[0]))
            if [[ "$2" == "--nowrap" ]]
            then
                ((current < limit )) && ((current = limit))
            else
                ((current < 0)) && current=0
            fi
            ;;
        down)
            ((current += prefix_args[0] * optcurrent[gridcolumns]))
            while ((current >= show))
            do
                ((current -= optcurrent[gridcolumns]))
            done
            ;;
        up)
            ((current -= prefix_args[0] * optcurrent[gridcolumns]))
            while ((current < 0))
            do
                ((current += optcurrent[gridcolumns]))
            done
            ;;
        right)
            ((limit = (current / optcurrent[gridcolumns]) * optcurrent[gridcolumns]))
            ((limit += optcurrent[gridcolumns] - 1))
            ((current += prefix_args[0]))
            if [[ "$2" == "--nowrap" ]]
            then
                ((current > limit )) && ((current = limit))
            else
                ((current >= show)) && ((current = show - 1))
            fi
            ;;
        "")
            get_image_index && ((current = image_index[0]))
            ;;
    esac
    update_fileinfo
    clear_sequence
}

_rotate() {
    local counter=0 degrees
    while [[ -n "$1" ]]
    do
        case "$1" in
            "--degrees")
                degrees="$2"
                shift
                ;;
            "--counter")
                counter=1
        esac
        shift
    done
    [[ -z "$degrees" ]] && degrees=90
    [[ "$counter" -eq 1 ]] && ((degrees = -degrees))
    run_edit_script "convert -rotate $degrees %in% %out%"
}

load_files() {
    local read_iter read_lock
    read -r read_lock < "${tmp_dir}/read_lock"
    # Simple lock mechanism. If read_images is running then quit.
    if [[ "$read_lock" -eq 0 ]]
    then
        read -r read_iter < "${tmp_dir}/read_iter"
        if ((read_iter < argc))
        then
            # read the max possible
            read_target="${optcurrent[maxload]}" && read_images &
        else
            warning="All files are loaded"
        fi
    fi
    clear_sequence
}

command_mode() {
        local cleanup=1 enter=0 input input_autocomplete="ucollage" input_left
        local input_prompt=":" input_right mode="command"
        [[ -n "$prefix" ]] && input_left="($prefix) "
        while [[ -n "$1" ]]
        do
            case "$1" in
                -l|--left)
                    input_left+="$2"
                    shift
                    ;;
                -r|--right)
                    input_right+="$2"
                    shift
                    ;;
                -e|--enter)
                    enter=1
                    ;;
            esac
            shift
        done
        input_left+="$1"
        input_right+="$2"
        [[ "$enter" -eq 1 ]] && input="${input_left}${input_right}"
        if [[ -n "$input" ]] || get_input
        then
            save_input=
            prefix=${input#*\(}
            prefix=${prefix%%)*}
            trim_spaces prefix
            [[ "$prefix" == "$input" ]] && prefix=
            [[ -n "$prefix" ]] && save_input+="($prefix) "
            full_cmd=${input#*)}
            trim_spaces full_cmd
            save_input+="$full_cmd"
            if [[ -n "$full_cmd" ]]
            then
                echo "$save_input" >> "$cache_dir/cmd_history"
                read -r cmd _ <<< "$full_cmd" # we take only the first word
                if [[ -n ${colon_cmd[$cmd]} ]]
                then
                    eval_cmd="${full_cmd//$cmd/${colon_cmd[$cmd]}}"
                    eval "$eval_cmd"
                    cleanup=0 # cleanup is being done by the executed function
                    # The setting of repeat_command has to happen after the eval
                    # because we want it to override the repeat_command with the 
                    # exact parameters that we gave.
                    repeat_command="command_mode --left \"$full_cmd\""
                else
                    error="Command not found: $cmd"
                fi
            fi
        fi
        if [[ "$cleanup" -eq 1 ]]
        then
            clear_sequence
        fi
        mode=
}

clear_sequence() {
    if [[ "$1" = "--repeat" ]]
    then
        repeat_prefix="$prefix"
        [[ -n "$mapping" ]] && repeat_command="${map_cmd[$mapping]}"
    fi
    lastvalidmapping=
    prefix=
    mapping=
}

######################################################################
# Populate the image_names, images and filehash arrays by reading the
# files written by the background process
######################################################################
populate_arrays() {
    echo 0 > "${tmp_dir}/dirty"
    # This is to read only new files in each iteration. Should scale well
    [[ ! -f "${tmp_dir}/image_names.txt" ]] || [[ ! -f "${tmp_dir}/images.txt" ]] ||\
        [[ ! -f "${tmp_dir}/hash.txt" ]] && return
    mv "${tmp_dir}/image_names.txt" "${tmp_dir}/image_names.txt.old"
    mv "${tmp_dir}/images.txt" "${tmp_dir}/images.txt.old"
    mv "${tmp_dir}/hash.txt" "${tmp_dir}/hash.txt.old"
    mapfile -t temp_names < "${tmp_dir}/image_names.txt.old"
    mapfile -t temp < "${tmp_dir}/images.txt.old"
    mapfile -t temp_hash < "${tmp_dir}/hash.txt.old"
    image_names+=("${temp_names[@]}")
    images+=("${temp[@]}")
    filehash+=("${temp_hash[@]}")
    total="${#images[@]}"
}

######################################################################
# Loop waiting for user input to execute actions
######################################################################
read_key() {
    local char key
    while true
    do
        [[ "$break_flag" -eq 1 ]] && break
        [[ "$exit_flag" -eq 1 ]] && break
        [[ "$total" -eq 0 ]] && stop_daemon
        key=
        char=
        while read -rsN1 -t 0.01 char &>/dev/null
        do
            key+="$char"
        done
        read -r dirty < "${tmp_dir}/dirty"
        [[ -z "$key" ]] && [[ "$dirty" -eq 0 ]] && continue
        # This is hack because $'\n' is not mapped correctly in map_cmd
        [[ "$key" == $'\n' ]] && key=$'\xD'
        case $key in
            $'\e')
                clear_sequence
                ;;
            [0-9])
                if [[ -z "$mapping" ]] && [[ ! "$prefix" =~ ^(\*+|;|#)$ ]]
                then
                    prefix+="$key"
                else
                    mapping+="$key"
                fi
                ;;
            " ")
                [[ ! "$prefix" =~ ^(\*+|;|#|)$ ]] && prefix+="$key"
                ;;
            "*")
                if [[ -n "$mapping" ]]
                then
                    mapping+="$key"
                elif [[ "$prefix" =~ ^\*+$ ]]
                then
                    prefix="**"
                else
                    prefix="*"
                fi
                ;;
            ";"|"#")
                [[ -z "$mapping" ]] && prefix="$key" || mapping+="$key"
                ;;
            ":")
                command_mode
                ;;
            $'\b'|$'\x7F')
                if [[ -n "$mapping" ]]
                then
                    mapping=${mapping:0:-1}
                elif [[ -n "$prefix" ]]
                then
                    prefix=${prefix:0:-1}
                elif [[ "$batch" -eq 1 ]]
                then
                    optcurrent[gridlines]="$wide_vertical"
                    optcurrent[gridcolumns]="$wide_horizontal"
                    ((current = (start % (wide_horizontal * wide_vertical))))
                    ((start = start - current))
                    redraw
                    clear_sequence
                elif [[ -z "$prefix" ]]
                then
                    mapping="$key"
                fi
                ;;
            ".")
                eval "$repeat_command"
                ;;
            *)
                mapping+="$key"
                ;;
        esac
        # This is coded in order to not follow mappings that do not lead to
        # any action. It also prevents the program from hanging in case of
        # pressing a not printable character (e.g Home, End) that does not
        # map to any command
        if [[ -n "$mapping" ]]
        then
            if [[ -n "${map_cmd[$mapping]}" ]]
            then
                eval "${map_cmd[$mapping]}"
            else
                good=0
                for m in "${!map_cmd[@]}"
                do
                    if [[ "$mapping" == "${m:0:${#mapping}}" ]]
                    then
                        good=1
                        lastvalidmapping="$mapping"
                        break
                    fi
                done
                [[ "$good" -eq 0 ]] && mapping="$lastvalidmapping"
            fi
        fi
        [[ "$exit_flag" -eq 1 ]] && continue
        if [[ "$dirty" -eq 1 ]]
        then
            populate_arrays
        fi
        update_status
    done
}

init() {
    clear_screen
    redraw
    update_status
    read_key
}

check_dependencies
[[ -f "$CONFIG_VARIABLES_FILE" ]] && source "$CONFIG_VARIABLES_FILE"
set_default
set_optcurrent
parse_config
set_scripts
[[ ! -d "$tmp_dir" ]] && mkdir -p "$tmp_dir"
[[ ! -d "$cache_dir" ]] && mkdir -p "$cache_dir"
[[ ! -d "$trash_dir" ]] && mkdir -p "$trash_dir"
[[ ! -d "${cache_dir}/hash/images" ]] && mkdir -p "${cache_dir}/hash/images"
[[ ! -d "${cache_dir}/hash/videos" ]] && mkdir -p "${cache_dir}/hash/videos"
[[ ! -d "${cache_dir}/hash/other" ]] && mkdir -p "${cache_dir}/hash/other"
[[ ! -d "${cache_dir}/thumbnails" ]] && mkdir -p "${cache_dir}/thumbnails"
[[ ! -f "${cache_dir}/cmd_history" ]] && touch "${cache_dir}/cmd_history"
[[ "$1" =~ ^-h$|^--help$ ]] && help && exit
trap "exit_flag=1" SIGINT SIGTERM
trap "redraw; update_status" SIGWINCH
start_daemon
exit_flag=0
dirty=0
status=
while [[ "$exit_flag" -eq 0 ]]
do
    read_filenames "$@"
    stty -echo
    unset start #make sure that start is not set, makes check in read_images
    ((first_batch = optcurrent[gridlines] * optcurrent[gridcolumns]))
    echo 0 > "${tmp_dir}/read_iter"
    echo 0 > "${tmp_dir}/read_lock"
    read_iter=0
    read_target="$first_batch" && read_images
    populate_arrays
    if [[ "$total" -eq 1 ]]
    then
        optcurrent[gridlines]=1
        optcurrent[gridcolumns]=1
        wide_vertical=1
        wide_horizontal=1
    fi
    read -r read_iter < "${tmp_dir}/read_iter"
    read_target="${optcurrent[maxload]}" && read_images & # read the max possible
    background_pid="$!"
    [[ "$total" -eq 0 ]] && printf "No images to show\n" && stty echo && \
        exit_clear=0 && break
    start=0
    declare -A assoc
    mode=
    break_flag=0
    current=0
    init
done
stop_daemon
