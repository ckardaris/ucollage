#!/usr/bin/env bash
config_error() {
    echo "Configuration error [${1}]: \"${2}\" ${3}"
}

parse_config() {
    errors=0

    [[ -n "$UCOLLAGE_LINES" ]] && ! is_natural "$UCOLLAGE_LINES" \
        && config_error "UCOLLAGE_LINES" "$UCOLLAGE_LINES" "is not a natural number" \
        && unset UCOLLAGE_LINES && errors=1
    [[ -n "$UCOLLAGE_COLUMNS" ]] && ! is_natural "$UCOLLAGE_COLUMNS" \
        && config_error "UCOLLAGE_COLUMNS" "$UCOLLAGE_COLUMNS" "is not a natural number" \
        && unset UCOLLAGE_COLUMNS && errors=1
    [[ -n "$UCOLLAGE_EXEC_PROMPT" ]] && [[ ! "$UCOLLAGE_EXEC_PROMPT" =~ ^(0|1)$ ]] \
        && config_error "UCOLLAGE_EXEC_PROMPT" "$UCOLLAGE_EXEC_PROMPT" " - valid values: 0, 1" \
        && unset UCOLLAGE_EXEC_PROMPT && errors=1

    [[ "$errors" -eq 1 ]] && read -rsN1
    unset errors
}

set_defaults() {
    fit_vertical=${UCOLLAGE_LINES:-3}
    fit_horizontal=${UCOLLAGE_COLUMNS:-4}
    tmp_dir=${UCOLLAGE_TMP_DIR:-"/tmp/ucollage"}
    exec_prompt=${UCOLLAGE_EXEC_PROMPT:-0}
    error=""
    warning=""
}

help(){
    echo "Usage: ucollage [images]"
    echo "Controls:"
    echo "  n       get next batch of images"

    echo "  N       get previous batch of images"

    echo "  h       decrease number of columns by 1"

    echo "  j       decrease number of lines by 1"

    echo "  k       increase number of lines by 1"

    echo "  l       increase number of columns by 1"

    echo "  -       decrease both the numbers of columns and lines by 1"

    echo "  +/=     increase both the numbers of columns and lines by 1"

    echo "  s       input exact number for lines and columns"

    echo "  q       exit"

    echo "  m       enter monocle mode: show only one image"

    echo "  M       exit monocle mode"

    echo "Monocle mode specific controls:"

    echo "  r       rotate image 90 degrees clockwise"

    echo "  R       rotate image 90 degrees counterclockwise"

    echo "  u       rotate image 180 degrees"

    echo "  x       execute command (placeholders are available for common substitutions)"
    echo "          %s - original image filename"
    echo "          %r - rotated image filename"
    echo "  c       rename image"
    exit
}

read_images() {
    images=()
    extensions=(bmp gif ico jpg jpeg png tif tiff webp)
    joined_extension="$(local IFS="|"; shift; echo "${extensions[*]}")"
    if [[ "$#" -gt 0 ]]
    then
        filelist=("$@")
    else
        filelist=(*)
    fi
    for file in "${filelist[@]}"
    do
        if [[ "${file,,}" =~ .${joined_extension,,}$ ]]
        then
            images+=("$file")
        else
            if [[ $(file --mime-type -b "$file") =~ ^image/.*$ ]]
            then
                images+=("$file")
                joined_extension+="|${file##*.}"
            fi
        fi
    done
}

clear_screen() {
    printf "\e[2J\e[?25l\e[H"
}

clear_messages() {
    success=""
    error=""
    warning=""
}

show_cursor() {
    printf "\e[?25h"
}

start_daemon() {
    fifo=$(mktemp --dry-run "${tmp_dir}/fifo-XXXXXXXXX")
    mkfifo "$fifo"
    ueberzug layer --parse bash --silent < "$fifo" &
    exec {colfd}> "$fifo"
}

stop_daemon() {
    exec {colfd}>&-
    rm "$fifo"
    [[ ! "$1" == "--no-exit" ]] && clear_screen && rm -rf "$tmp_dir" && show_cursor && exit
}

restart_daemon() {
    stop_daemon --no-exit
    start_daemon
}

calculate_dimensions() {
    read -r lines columns < <(stty size)
    (( photo_columns = columns / fit_horizontal ))
    (( photo_lines = (lines - 3) / fit_vertical ))
    (( batch = fit_horizontal * fit_vertical ))
    (( show = total - start ))
    [[ "$show" -gt "$batch" ]] && show="$batch"
}

show_batch() {
    cnt=0
    [[ "$show" -le 0 ]] && return
    for (( i = 0; i < fit_vertical; i++ ))
    do
        for (( j = 0; j < fit_horizontal; j++, cnt++ ))
        do
            (( index = start + i * fit_horizontal + j))
            (( posx = j * photo_columns))
            (( posy = 3 + i * photo_lines))
            if [[ "$cnt" -ge "$show" ]]
            then
                assoc=( [action]=remove \
                        [identifier]="${fifo}${i}${j}" )
            else
                assoc=( [action]=add \
                        [identifier]="${fifo}${i}${j}" \
                        [path]="${images[$index]}" \
                        [width]="$photo_columns" \
                        [height]="$photo_lines" \
                        [x]="$posx" \
                        [y]="$posy" \
                        [scaler]=fit_contain )
            fi
            declare -p assoc > "$fifo"
        done
    done
}

compute_batch() {
    case $1 in
        next)
            if (( start + batch < total ))
            then
                rm -f "$rotated_file"
                (( start += batch))
                (( show = total - start ))
                [[ "$show" -gt "$batch" ]] && show="$batch"
            else
                warning="End of files"
            fi
            ;;
        prev)
            [[ "$start" -le 0 ]] && warning="Start of files" && return
            rm -f "$rotated_file"
            (( start -= batch))
            # The below is useful in case of resizing
            # If I am in the second of batches of 10 and the
            # new window fits 20 then I don't want negative numbers
            [[ "$start" -lt 0 ]] && start=0
            show="$batch"
            ;;
    esac
}

get_input() {
    show_cursor
    printf "%s\e7" "$1"
    left=""
    right=""
    while true
    do
        printf "\e8\e[K"
        move=""
        [[ -n "$right" ]] && move="\e[${#right}D"
        printf "%s%s$move" "$left" "$right"
        read -rsN1 char
        read -rsN1 -t 0.0001 k1
        read -rsN1 -t 0.0001 k2
        read -rsN1 -t 0.0001 k3
        read -rsN1 -t 0.0001 k4
        key="${char}${k1}${k2}${k3}${k4}"
        case "$key" in
            $'\e[D') #left arrow press
                if [[ -n "$left" ]]
                then
                    right="${left: -1}$right";
                    left="${left:0:-1}"
                fi
                continue
                ;;
            $'\e[C') #right arrow press
                if [[ -n "$right" ]]
                then
                    left="$left${right:0:1}"
                    right="${right:1}";
                fi
                continue
                ;;
            $'\e[H'|$'\e[1~')
                right="${left}${right}"
                left=""
                continue
                ;;
            $'\e[F'|$'\e[4~')
                left="${left}${right}"
                right=""
                continue
                ;;
            $'\e[3~'|$'\e[P')
                [[ -n "$right" ]] && right="${right:1}"
                continue
                ;;
            $'\e')
                input="ESCAPE";
                break
                ;;
            $'\b'|$'\x7F')
                [[ -n "$left" ]] && left="${left:0:-1}"
                continue
                ;;
            $'\n')
                input="$left$right";
                break
                ;;
            [0-9]|[A-Z]|[a-z]|' '|[\/\:\;\|\<\>?+\-%._\\*@!$])
                left+="$key"
                continue
                ;;
            *)
                continue
                ;;
        esac
    done
}

is_natural() {
    [[ "$1" =~ ^[1-9][0-9]*$|^0+[1-9]+$ ]]
}

give_dimensions() {
    new_fit_vertical="$fit_vertical"
    new_fit_horizontal="$fit_horizontal"
    read -r lines columns < <(stty size)
    (( max_lines = lines -3 ))

    get_input "Give number of lines [default: $fit_vertical, max: $max_lines]: "
    [[ "$input" == "ESCAPE" ]] && return
    [[ -n "$input" ]] && ! is_natural "$input" && set_error lines "$input" && return
    [[ -n "$input" && ! "$input" -eq "$fit_vertical" ]] && (( new_fit_vertical = input ))

    printf "\n"
    get_input "Give number of columns [Default: $fit_horizontal, Max: $columns]: "
    [[ "$input" == "ESCAPE" ]] && return
    [[ -n "$input" ]] && ! is_natural "$input" && set_error columns "$input" && return
    [[ -n "$input" && ! "$input" -eq "$photo_columns" ]] && (( new_fit_horizontal = input ))
    clear_screen
}

set_error() {
    error="(Error) Invalid value for $1: $2"
}

redraw() {
    restart_daemon
    calculate_dimensions
    if [[ "$show" -eq 1 && -f "$rotated_file" ]]
    then
        assoc=( [action]=add \
                [identifier]="${fifo}00" \
                [path]="$rotated_file" \
                [width]="$photo_columns" \
                [height]="$photo_lines" \
                [x]="$posx" \
                [y]="$posy" \
                [scaler]=fit_contain )
        declare -p assoc > "$fifo"
    else
        show_batch
    fi
    clear_screen
}

maybe_redraw() {
    read -r lines columns < <(stty size)
    if (( new_fit_vertical != fit_vertical || new_fit_horizontal != fit_horizontal ))
    then
        (( new_fit_vertical > lines - 3 || new_fit_vertical < 1 )) \
            && set_error lines "$new_fit_vertical" && return
        (( new_fit_horizontal > columns || new_fit_horizontal < 1 )) \
            && set_error columns "$new_fit_horizontal" && return
        fit_vertical="$new_fit_vertical"
        fit_horizontal="$new_fit_horizontal"
        redraw
    fi
}

print_status() {
    status="[$fit_vertical x $fit_horizontal]"
    if [[ "$show" -gt 1 ]]
    then
        ((begin = start + 1))
        ((finish = begin + show - 1))
        status+=" - Photos [$begin - $finish] of $total"
    else
        ((begin = start + 1))
        status+=" - Photo $begin of $total - ${images[$start]}"
    fi
    printf "%s" "$status"
}

in_monocle() {
    [[ $show -gt 1 ]] && warning="${1} option available for single images. Press [m] to enter monocle mode" && return 1
    return 0
}

rotate() {
    ! in_monocle "Rotate" && return
    ! command -v convert &> /dev/null && error="imagemagick not installed: required for rotation of images" && return
    ! command -v basename &> /dev/null && error="basename not installed: required for rotation of images" && return
    rotated_file="${tmp_dir}/rotated-$(basename "${images[$start]}")"
    [[ ! -f "$rotated_file" ]] && cp "${images[$start]}" "$rotated_file"
    convert -rotate "$1" "$rotated_file" "$rotated_file"
    assoc=( [action]=add \
            [identifier]="${fifo}00" \
            [path]="$rotated_file" \
            [width]="$photo_columns" \
            [height]="$photo_lines" \
            [x]="$posx" \
            [y]="$posy" \
            [scaler]=fit_contain )
    declare -p assoc > "$fifo"
}

eval_cmd() {
    if [[ "$exec_prompt" -eq 1 ]]
    then
        clear_screen
        printf "%s? (press n/N/Esc to abort)" "$1"
        read -rsN1 ans
        if [[ ! "$ans" =~ ^(n|N)$ ]] && [[ ! "$ans" == $'\e' ]]
        then
            error=$(eval "$2" 2>&1 >/dev/null)
            [[ -z "$error" ]] && success="Successful execution" && return 0
        fi
    else
        error=$(eval "$cmd" 2>&1 >/dev/null)
        [[ -z "$error" ]] && success="Successful execution" && return 0
    fi
    return 1
}

execute() {
    ! in_monocle "Execute" && return
    get_input "Command (add %s for the current file): "
    [[ "$input" == "ESCAPE" ]] && clear_screen && return
    cmd=${input//%s/${images[$start]}}
    cmd=${cmd//%r/${rotated_file}}
    eval_cmd "Execute: \"${cmd}\"" "$cmd"
    clear_screen
}

rename() {
    ! in_monocle "Rename" && return
    printf "Old name: %s\n" "${images[$start]}"
    get_input "New name: "
    [[ "$input" == "ESCAPE" ]] && clear_screen && return
    cmd="mv ${images[$start]} $input"
    eval_cmd "Rename to: \"${input}\"" "$cmd" && images[$start]="$input"
    clear_screen
}

read_key() {
    while true
    do
        calculate_dimensions
        clear_screen
        if [[ -n "$success" ]]
        then
            printf "\e[32m%s\e[m" "$success"
        elif [[ -n "$error" ]]
        then
            printf "\e[31m%s\e[m" "$error"
        elif [[ -n "$warning" ]]
        then
            printf "\e[33m%s\e[m" "$warning"
        else
            print_status
        fi
        read -rsN1 -t 0.001 key
        case $key in
            q)
                stop_daemon
                break
                ;;
            n)
                clear_messages
                compute_batch next
                show_batch
                ;;
            N)
                clear_messages
                compute_batch prev
                show_batch
                ;;
            s)
                clear_messages
                clear_screen
                give_dimensions
                maybe_redraw
                ;;
            +|=)
                clear_messages
                (( new_fit_vertical = fit_vertical + 1 ))
                (( new_fit_horizontal = fit_horizontal + 1 ))
                maybe_redraw
                ;;
            -)
                clear_messages
                (( new_fit_vertical = fit_vertical - 1 ))
                (( new_fit_horizontal = fit_horizontal -1 ))
                maybe_redraw
                ;;
            m)
                clear_messages
                if [[ "$show" -gt 1 ]]
                then
                    monocle_vertical="$fit_vertical"
                    monocle_horizontal="$fit_horizontal"
                    new_fit_vertical=1
                    new_fit_horizontal=1
                    maybe_redraw
                fi
                ;;
            M)
                clear_messages
                if [[ "$show" -gt 1 ]]
                then
                    warning="[M] is only available in monocle mode"
                else
                    new_fit_vertical="$monocle_vertical"
                    new_fit_horizontal="$monocle_horizontal"
                    maybe_redraw
                fi
                ;;
            k)
                clear_messages
                (( new_fit_vertical = fit_vertical + 1 ))
                (( new_fit_horizontal = fit_horizontal ))
                maybe_redraw
                ;;
            j)
                clear_messages
                (( new_fit_vertical = fit_vertical - 1 ))
                (( new_fit_horizontal = fit_horizontal ))
                maybe_redraw
                ;;
            l)
                clear_messages
                (( new_fit_vertical = fit_vertical ))
                (( new_fit_horizontal = fit_horizontal + 1 ))
                maybe_redraw
                ;;
            h)
                clear_messages
                (( new_fit_vertical = fit_vertical ))
                (( new_fit_horizontal = fit_horizontal - 1 ))
                maybe_redraw
                ;;
            r)
                clear_messages
                rotate 90
                ;;
            R)
                clear_messages
                rotate -90
                ;;
            u)
                clear_messages
                rotate 180
                ;;
            x)
                clear_messages
                clear_screen
                execute
                ;;
            c)
                clear_messages
                clear_screen
                rename
                ;;
            $'\e'|$'\n')
                clear_messages
                clear_screen
                ;;
        esac
    done
}

! command -v ueberzug &> /dev/null && echo "Ueberzug not installed: ucollage dependency" && exit 1
parse_config
set_defaults
[[ ! -d "$tmp_dir" ]] && mkdir -p "$tmp_dir"
trap stop_daemon SIGINT
trap redraw SIGWINCH
[[ "$1" =~ ^-h$|^--help$ ]] && help
read_images "$@"
total="${#images[@]}"
[[ "$total" -eq 0 ]] && echo "No images to show" && exit 1
show="$total"
start=0
declare -A assoc
start_daemon
calculate_dimensions
show_batch
clear_screen
read_key
