#!/usr/bin/env bash
shopt -s extglob

trim_spaces() {
    local -n str="$1"
    str="${str##*( )}"
    str="${str%%*( )}"
    str="${str//+( )/ }"
    case "$2" in
        "--colon")
            str="${str//*( );*( )/;}"
            ;;
    esac
}

declare -A use_script
declare -A edit_script=([r]="convert -rotate 90 %in% %out%; Rotate clockwise; rotateright"
                        [R]="convert -rotate -90 %in% %out%; Rotate counter-clockwise; rotateleft"
                       )
declare -A filehash
CONFIG_FILE="$HOME/.config/ucollage/config.sh"
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"
declare -A colon_cmd=([delete]="delete_image"
                      [tag]="tag_image tag"
                      [untag]="tag_image untag"
                      [goto]="goto_image" 
                      [undo]="edit_history --undo"
                      [redo]="edit_history --redo"
                      [write]="save_edits"
                      [rename]="rename"
                      [quit]="stop_daemon"
                      [sort]="change_sort"
                      [scaler]="change_scaler"
                      [toggle]="toggle"
                      [setgrid]="change_dimensions"
                      [grid]="grid"
                      [batch]="compute_batch"
                      [!]="execute same"
                      [!%]="execute group"
                     )
for i in "${!edit_script[@]}"
do
    entry="${edit_script[$i]}"
    trim_spaces entry --colon
    edit_script[$i]="$entry"
    IFS=';' read -r -a entry_arr <<< "$entry"
    cmd="${entry_arr[2]}"
    colon_cmd[$cmd]="run_edit_script"
done
for i in "${!use_script[@]}"
do
    entry="${use_script[$i]}"
    trim_spaces entry --colon
    use_script[$i]="$entry"
    IFS=';' read -r -a entry_arr <<< "$entry"
    cmd="${entry_arr[2]}"
    colon_cmd[$cmd]="run_use_script"
done

check_config_variable() {
    [[ -z "${!variable_name}" ]] && return
    eval "[[ \"${!variable_name}\" =~ $accept_regexp ]]" && return
    if [[ "$errors" -eq 0 ]]
    then
        echo "Error: configuration"
        echo "--------------------"
    fi
    echo "[$variable_name]"
    echo "Value: ${!variable_name}"
    echo "Valid: $valid_values"
    echo "--------------------"
    eval "${variable_name}=" #unset the variable
    errors=1
}

parse_config() {
    local errors=0

    variable_name="UCOLLAGE_LINES"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$" # is natural
    valid_values="natural numbers"
    check_config_variable

    variable_name="UCOLLAGE_COLUMNS"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$"
    valid_values="natural numbers"
    check_config_variable

    variable_name="UCOLLAGE_EXEC_PROMPT"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_SHOW_NAMES"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_EXPAND_DIRS"
    accept_regexp="^(0|1|ask)$"
    valid_values="0, 1, ask"
    check_config_variable

    variable_name="UCOLLAGE_SORT_BY"
    accept_regexp="^(name|time|size|extension)$"
    valid_values="name, time, size, extension"
    check_config_variable

    variable_name="UCOLLAGE_SORT_REVERSE"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_SCALER"
    accept_regexp="^(crop|distort|fit_contain|contain|forced_cover|cover)$"
    valid_values="crop, distort, fit_contain, contain, forced_cover, cover"
    check_config_variable

    variable_name="UCOLLAGE_VIDEO_THUMBNAILS"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_CACHE_THUMBNAILS"
    accept_regexp="^(0|1)$"
    valid_values="0, 1"
    check_config_variable

    variable_name="UCOLLAGE_THUMBNAIL_WIDTH"
    accept_regexp="^([1-9][0-9]*|0+[1-9][0-9]*)$" # is natural
    valid_values="natural numbers"
    check_config_variable

    [[ "$errors" -eq 1 ]] && read -rsN1 -p "Using default variables..." && echo
}

set_defaults() {
    fit_vertical=${UCOLLAGE_LINES:-3}
    fit_horizontal=${UCOLLAGE_COLUMNS:-4}
    max_fit_vertical="${UCOLLAGE_MAX_LINES:-20}"
    max_fit_horizontal="${UCOLLAGE_MAX_COLUMNS:-20}"
    wide_vertical="$fit_vertical"
    wide_horizontal="$fit_horizontal"
    wide_current=1
    old_fit_vertical="$fit_vertical"
    old_fit_horizontal="$fit_horizontal"
    tmp_dir=${UCOLLAGE_TMP_DIR:-/tmp/ucollage}
    cache_dir=${UCOLLAGE_CACHE_DIR:-~/.local/share/ucollage}
    trash_dir=${UCOLLAGE_TRASH_DIR:-~/.local/share/Trash/ucollage}
    exec_prompt=${UCOLLAGE_EXEC_PROMPT:-0}
    show_names=${UCOLLAGE_SHOW_NAMES:-1}
    expand_dirs=${UCOLLAGE_EXPAND_DIRS:-ask}
    sort_by=${UCOLLAGE_SORT_BY:-name}
    sort_reverse=${UCOLLAGE_SORT_REVERSE:-0}
    scaler=${UCOLLAGE_SCALER:-contain}
    video_thumbnails=${UCOLLAGE_VIDEO_THUMBNAILS:-1}
    cache_thumbnails=${UCOLLAGE_CACHE_THUMBNAILS:-1}
    thumbnail_width=${UCOLLAGE_THUMBNAIL_WIDTH:-500}
    error=""
    warning=""
    success=""
    prefix=""
    exit_clear=1
}

help(){
    echo "Usage: ucollage [images] [directories]"
    echo
    echo "Controls:"
    echo "  Backspace            exit monocle mode"
    echo "  :                    enter command mode"
    echo "  .                    repeat last action (a new prefix must be given)"
    echo "  n/right arrow        get next batch of images"
    echo "  N/shift+right arrow  get last batch of images"
    echo "  p/left arrow         get previous batch of images"
    echo "  P/shift+left arrow   get first batch of images"
    echo "  tp                   toggle exec prompt"
    echo "  tn                   toggle filenames on screen"
    echo "  ss                   set sort type"
    echo "  tr                   toggle reverse sort"
    echo "  su                   set ueberzug scaler"
    echo "  q                    exit"
    echo
    echo "Controls with vim-like prefix counters"
    echo "  (N)-        decrease both the numbers of columns and lines by N"
    echo "  (N)+/=      increase both the numbers of columns and lines by N"
    echo "  (N)ci       rename image with index N"
    echo "  (N)di       move image with index N to Trash"
    echo "  (N)u        undo edits of image with index N"
    echo "  (N)Ctrl+r   redo edits of image with index N"
    echo "  (N)r        rotate clockwise image with index N"
    echo "  (N)R        rotate counter-clockwise image with index N"
    echo "  (N)h        decrease number of columns by N"
    echo "  (N)j        decrease number of lines by N"
    echo "  (N)k        increase number of lines by N"
    echo "  (N)l        increase number of columns by N"
    echo "  (N)gi       enter monocle mode; go to image with index N"
    echo "  (N)sg       set grid size"
    echo "  (N)ti       tag image with index N"
    echo "  (N)dt       untag image with index N"
    echo "  (N)wi       save edits of image with index N"
    echo "  (N)xi       execute different commands for each image with index N"
    echo "              placeholders are available for command execution"
    echo "                  %s - image filename"
    echo "                  %e - edited image filename"
    echo "  (N)xs       execute same command for each image with index N"
    echo "              placeholders are available for command execution"
    echo "                  %s - image filename"
    echo "                  %e - edited image filename"
    echo "  (N)xg       execute one command for all images with index N"
    echo "              placeholders"
    echo "                  %S - all image filenames side by side"
    echo "                  %E - all edited image filenames side by side"
}

check_dependencies() {
    local dependency
    declare -A dep
    dep[ueberzug]="ueberzug"
    dep[file]="file"
    dep[xxh128sum]="xxhash"
    for dependency in ueberzug file xxh128sum
    do
        if ! command -v "$dependency" &>/dev/null
        then
            echo "Required dependency not installed: ${dep[$dependency]}" && exit
        fi
    done
}

######################################################################
# Create filelist
# Uses:
#   sort_by
#   sort_reverse
#   expand_dirs
# Modifies:
#   filelist
#   image_names
#   images
#   read_iter
#   argc
# Arguments:
#   $@              command line arguments
######################################################################
read_filenames() {
    local ls_args="-d"
    [[ "$sort_reverse" -eq 1 ]] && ls_args+=" -r"
    case "$sort_by" in
        "time")
            ls_args+=" -t"
            ;;
        "size")
            ls_args+=" -S"
            ;;
        "extension")
            ls_args+=" -X"
            ;;
    esac
    if [[ "$#" -gt 0 ]]
    then
        mapfile -t filelist < <(ls $ls_args "$@")
    else
        mapfile -t filelist < <(ls $ls_args -- *)
    fi
    local item
    if [[ "$expand_dirs" -eq 1 ]]
    then
        for item in "${filelist[@]}"
        do
            [[ -d "$item" ]] && filelist+=("$item"/*)
        done
    elif [[ "$expand_dirs" == "ask" ]]
    then
        for item in "${filelist[@]}"
        do
            [[ -d "$item" ]] \
                && read -p "Expand $item? (n, Esc: no, N: no to all)" -rsN1 char \
                && echo
            [[ "$char" == "N" ]] && break
            [[ ! "$char" =~ ^(n|$'\e')$ ]] && filelist+=("$item"/*)
        done
    fi
    argc="${#filelist[@]}"
    image_names=()
    images=()
    rm -f "${tmp_dir}/image_names.txt*"
    rm -f "${tmp_dir}/images.txt*"
    read_iter=0
}

######################################################################
# Search for thumbnail of file in cache directory
# Uses:
#   file
#   cache_dir
# Modifies:
#   thumbnail_file
#   cache_name
# Return:
#   0 thumbnail file was found
#   1 thumbnail file was not found
######################################################################
find_thumbnail() {
    cache_name="${cache_dir}/thumbnails/${hash}.jpg"
    [[ -f "$cache_name" ]] && thumbnail_file="$cache_name" && return 0
    return 1
}

######################################################################
# Create thumbnail for file
# Uses:
#   file
#   tmp_dir
#   thumbnail_width
# Modifies:
#   thumbnail_file
######################################################################
create_thumbnail() {
    thumbnail_file="${tmp_dir}/${hash}.jpg"
    eval "$(ffprobe -i "$file" -show_entries format=duration -v quiet -of flat="s=_")"
    format_duration=${format_duration/.*/}
    (( time_point = format_duration / 2 ))
    ffmpeg -ss "$time_point" -i "$file" -loglevel quiet -frames:v 1 \
        -filter:v scale="$thumbnail_width":-1 -y "$thumbnail_file"
    montage -label "thumbnail" "$thumbnail_file" -geometry +0+0 -background Gold "$thumbnail_file"
}

is_image() {
    [[ -f "${cache_dir}/hash/images/${hash}" ]] && return 0
    if [[ $(file --mime-type -b "$file") =~ ^image/.*$ ]]
    then
        touch "${cache_dir}/hash/images/${hash}"
        return 0
    fi
    return 1
}

is_video() {
    [[ -f "${cache_dir}/hash/videos/${hash}" ]] && return 0
    if [[ $(file --mime-type -b "$file") =~ ^video/.*$ ]]
    then
        touch "${cache_dir}/hash/videos/${hash}"
        return 0
    fi
    return 1
}
######################################################################
# Parses filelist and filters supported filetypes
# Uses:
#   filelist
#   read_iter       number of files already parsed
#   read_target     maximum number of files to parse
#   argc            total number of files given as arguments
#   tmp_dir
#   thumbnail_file
#   video_thumbnails
#   cache_thumbnails
#   cache_name
#   start
# Modifies:
#   read_iter
# Outputs:
#   appends file names into the file ${tmp_dir}/image_names.txt
#   appends the image names corresponding to the above into the file ${tmp_dir}/images.txt
#   touches file ${tmp_dir}/done_reading if all files are parsed
#   prints a dot for every file with unsupported type if the user interface is not yet up
# Arguments:
#   $1              if "--remaining" parse the rest of the files
######################################################################
read_images() {
    readc=0
    while [[ "$1" == "--remaining" ]] || (( readc < read_target )) && (( read_iter < argc ))
    do
        file=${filelist[$read_iter]}
        read -d ' ' hash < <(head -c 100000 "$file" 2>/dev/null | xxh128sum)
        if is_image "$file"
        then
            echo "$file" >> "${tmp_dir}/image_names.txt"
            echo "$file" >> "${tmp_dir}/images.txt"
            (( readc += 1 ))
        elif is_video "$file" \
            && [[ "$video_thumbnails" -eq 1 ]] \
            && command -v ffmpeg &> /dev/null
        then
            ! find_thumbnail && create_thumbnail
            echo "$file" >> "${tmp_dir}/image_names.txt"
            echo "$thumbnail_file" >> "${tmp_dir}/images.txt"
            if [[ "$cache_thumbnails" -eq 1 ]] && [[ ! "$thumbnail_file" == "$cache_name" ]]
            then
                cp -f "$thumbnail_file" "$cache_name"
            fi
            (( readc += 1 ))
        else
            touch "${cache_dir}/hash/other/${hash}"
            [[ ! "$1" == "--remaining" ]] && printf "." # only print if ui is not started
        fi
        (( read_iter += 1 ))
    done
    printf "\n"
    [[ "$1" == "--remaining" ]] \
        && true > "${tmp_dir}/done_reading" \
        || rm -f "${tmp_dir}/done_reading"
}

######################################################################
# 2J                Clear entire screen
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
######################################################################
clear_screen() {
    printf "\e[2J\e[?25l\e[H"
}

######################################################################
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
# 2B                Move cursor down 2 lines
# 2K                Clear entire line
# 1J                Clear screen from cursor up
######################################################################
clear_status() {
    if [[ "$1" == "--cmdline" ]] #clear 2nd and 3rd line
    then
        printf "\e[?25l\e[H\e[2B\e[2K\e[1A\e[2K\e[2;1H"
        cmd_status=
        return
    fi
    # clear only first three lines of screen
    printf "\e[?25l\e[H\e[2B\e[2K\e[1J\e[H"
    status=""
    cmd_status=""
}

######################################################################
# ?25l              Hide cursor
# H                 Move cursor to upper left corner
# 3B                Move cursor down 3 lines
# 2K                Clear entire line
# 0J                Clear screen from cursor down
######################################################################
clear_names() {
    # clear from 4th line and down
    printf "\e[?25l\e[H\e[3B\e[2K\e[0J\e[H"
}

show_cursor() {
    printf "\e[?25h"
}

######################################################################
# Starts the ueberzug daemon
# Uses:
#   tmp_dir
# Modifies:
#   fifo
# Outputs:
#   creates the fifo file
######################################################################
start_daemon() {
    fifo="${tmp_dir}/fifo"
    mkfifo "$fifo"
    ueberzug layer --parse bash --silent < "$fifo" &
    exec {ueberzug}> "$fifo"
}

stop_daemon() {
    exec {ueberzug}>&-
    [[ "$exit_clear" == 1 ]] && clear_screen
    kill "$background_pid" &>/dev/null
    rm -rf "$tmp_dir"
    printf "\e[?25h"
    stty echo
}

######################################################################
# Calculates the parameters for the current view
# Uses:
#   fit_vertical
#   fit_horizontal
#   start
# Modifies:
#   photo_columns
#   photo_lines
#   batch
#   show
######################################################################
calculate_dimensions() {
    read -r lines columns < <(stty size)
    (( batch = fit_horizontal * fit_vertical ))
    if [[ "$show_names" -eq 1 ]] && [[ "$batch" -gt 1 ]]
    then
        (( photo_columns = (columns - 2) / fit_horizontal ))
        (( photo_lines = (lines - 4) / fit_vertical ))
    else
        (( photo_columns = columns / fit_horizontal ))
        (( photo_lines = (lines - 3) / fit_vertical ))
    fi
    (( show = total - start ))
    [[ "$show" -gt "$batch" ]] && show="$batch"
    [[ "$current" -gt "$show" ]] && current="$show"
}

######################################################################
# Pads strings with filenames to fit into the given column width
# Uses:
#   current_name
#   photo_columns
# Modifies:
#   current_name
######################################################################
pad_sides() {
    (( leftpad = $1 / 2 ))
    (( rightpad = $1 - leftpad ))
    local p
    for (( p = 0; p < leftpad; p++))
    do
        current_name=" $current_name"
    done
    for (( p = 0; p < rightpad; p++))
    do
        current_name+=" "
    done
}

######################################################################
# Draws the current batch of images on the screen
# Uses:
#   show
#   show_names
#   fit_vertical
#   fit_horizontal
#   start
#   images
#   scaler
#   fifo
######################################################################
show_batch() {
    cnt=0
    [[ "$show" -lt 1 ]] && return
    if [[ "$show_names" -eq 1 ]] && [[ "$show" -gt 1 ]]
    then
        # Substracting 3 lines is a hack. The names can be printed in
        # two lines, but ueberzug is not exact in its drawing on the
        # terminal lines for different window sizes.
        # So I give it some more room for error.
        (( draw_lines = photo_lines - 3 ))
    else
        draw_lines="$photo_lines"
    fi
    local i
    (( limit_i = old_fit_vertical > fit_vertical ? old_fit_vertical : fit_vertical ))
    (( limit_j = old_fit_horizontal > fit_horizontal ? old_fit_horizontal : fit_horizontal ))
    for (( i = 0; i < limit_i; i++ ))
    do
        for (( j = 0; j < limit_j; j++))
        do
            if (( i < fit_vertical && j < fit_horizontal))
            then
                (( index = start + i * fit_horizontal + j))
                if [[ "$show_names" -eq 1 ]] && [[ "$batch" -gt 1 ]]
                then
                    (( posx = 1 + j * photo_columns))
                    (( posy = 4 + i * photo_lines))
                else
                    (( posx = j * photo_columns))
                    (( posy = 3 + i * photo_lines))
                fi
                assoc=( [action]=add \
                        [identifier]="${fifo}${i}${j}" \
                        [path]="${images[$index]}" \
                        [width]="$photo_columns" \
                        [height]="$draw_lines" \
                        [x]="$posx" \
                        [y]="$posy" \
                        [scaler]="$scaler" )
            else
                assoc=( [action]=remove \
                        [identifier]="${fifo}${i}${j}" )
            fi
            declare -p assoc > "$fifo"
        done
    done
}

######################################################################
# Modifies the parameters needed to show another batch
# Uses:
#   start
#   show
# Modifies:
#   new_start
#   warning
# Return:
#   0               new batch is different than the current
#   1               new batch is the same as the current
######################################################################
compute_batch() {
    old_fit_vertical="$fit_vertical"
    old_fit_horizontal="$fit_horizontal"
    new_fit_vertical="$fit_vertical"
    new_fit_horizontal="$fit_horizontal"
    input="$1"
    if [[ -z "$input" ]]
    then
        input_autocomplete="batch"
        input_prompt="Batch # "
        clear_status --cmdline
        get_input
    fi
    case $input in
        next)
            # There exists an edge case here when $show is less that
            # $batch, but we are not in the last batch of images
            # This can happen when we are loading the images in the background
            # and the user has changes the batch size with the 's' option
            # right after starting up.
            if (( start + show < total ))
            then
                (( new_start = start + show ))
            else
                warning="End of files"
            fi
            ;;
        last)
            (( new_start = total - ((total - 1) % batch + 1) ))
            [[ "$new_start" -le "$start" ]] && warning="End of files"
            ;;
        previous)
            [[ "$start" -eq 0 ]] && warning="Start of files"
            (( new_start = start - batch))
            # The below is useful in case of resizing
            # If I am in the second of batches of 10 and the
            # new window fits 20 then I don't want negative numbers
            [[ "$new_start" -lt 0 ]] && new_start=0
            ;;
        first)
            [[ "$start" -eq 0 ]] && warning="Start of files"
            new_start=0
            ;;
        *)
            [[ -n "$input" ]] && error="Unknown option: $input"
            ;;
    esac
    [[ -z "$warning" ]] && [[ -z "$error" ]] && maybe_redraw
    clear_sequence
    update_status
}

######################################################################
# Calculates the next suggestion from the autocomplete array
# Uses:
#   autocomplete
#   suggestion_count
# Modifies:
#   suggestion_index
#   suggestion
# Arguments:
#   $1              prev or next, depending on the direction we are cycling
######################################################################
set_suggestion() {
    # if suggestion count is 2 then that means that there is only one suggestion
    # that along with the input makes the count 2. In that case the suggestion
    # should be selected.
    [[ "$suggestion_count" -eq 2 ]] && suggestion="${autocomplete[1]}" && clear_suggestions && return
    if [[ "$1" == "next" ]]
    then
        (( suggestion_index = (suggestion_index + 1) % suggestion_count ))
    elif [[ "$1" == "prev" ]]
    then
        (( suggestion_index = (suggestion_index - 1) % suggestion_count ))
    fi
    suggestion="${autocomplete[$suggestion_index]}"
}

######################################################################
# Saves the suggestion as input and clears everything related to autocomplete
# Uses:
#   suggestion
# Modifies:
#   left
#   suggestion
#   autocomplete
######################################################################
clear_suggestions() {
    [[ -z "$suggestion" ]] && return
    input_left="$suggestion"
    suggestion=""
    suggestion_count=0
    unset autocomplete
    unset subinput_autocomplete
}

clear_history() {
    if [[ -n "$input_history" ]]
    then
        input_left="$input_history"
        input_right=
        unset input_history
    fi
    [[ "$1" == "--force" ]] && cmd_history=()
}

######################################################################
# Escapes special characters in filenames in order to not have a problem
# with command execution. Should be used like var=$(escape_name "$var")
# Arguments:
#   $1              The name we want to escape chars for
# Outputs:
#   $2              Prints the updated name
######################################################################
escape_name() {
    local name="$1"
    name="${name// /\\ }"
    name="${name//\(/\\\(}"
    name="${name//\)/\\\)}"
    name="${name//\{/\\\{}"
    name="${name//\}/\\\}}"
    printf "%s" "$name"
}

######################################################################
# Creates the automplete array based on the autocomplete type we want
# Uses:
#   left
# Modifies:
#   autocomplete
# Arguments:
#   $1              autocomplete type: command, file, etc.
# Return:
#   0               if autocomplete array was created
#   1               if array was not created for any reason
######################################################################
create_suggestions() {
    local files=0
    if [[ "$input_autocomplete" == "ucollage" ]]
    then
        input_left=${input_left/)*( )/) }
    fi
    IFS=" " read -r -a split_left <<< "$input_left"
    #this trick also determines the way i handle the prefix in command mode
    #i add a space after the parenthesis so that the command is its own word
    [[ "${input_left: -1}" == " " ]] && split_left+=("") 
    #we do that so that a space confirms a suggestion
    if [[ "${#split_left[@]}" -eq 0 ]]
    then
        local word=
    else
        local word="${split_left[-1]}"
    fi
    subinput_autocomplete="$input_autocomplete"
    
    if [[ "$input_autocomplete" == "ucollage" ]] || \
        [[ "$input_autocomplete" == "command" ]]
    then
        local passed=0 # this checks that I have already written a command
        for ((i = 0; i < ${#split_left[@]} - 1; i++))
        do
            command -v ${split_left[$i]} &>/dev/null && \
                [[ ${split_left[$i]} != "!" ]] && passed=1
        done
        [[ "$passed" -eq 1 ]] && subinput_autocomplete="file"
    fi
    
    # It is important that this overrides the above loop check because it
    # is possible that a keyword exists as a system command (e.g sort)
    if [[ "$input_autocomplete" == "ucollage" ]] && [[ "${#split_left[@]}" -gt 1 ]]
    then
        case "${split_left[-2]}" in
            "scaler")
                subinput_autocomplete="scaler"
                ;;
            "sort")
                subinput_autocomplete="sort"
                ;;
            "toggle")
                subinput_autocomplete="toggle"
                ;;
            "batch")
                subinput_autocomplete="batch"
                ;;
            !|!%)
                subinput_autocomplete="command"
                ;;
            "grid")
                subinput_autocomplete="grid"
        esac
    fi

    case "$subinput_autocomplete" in
        "command")
            mapfile -t autocomplete < <(compgen -c "$word" | sort)
            ;;
        "file")
            mapfile -t autocomplete < <(compgen -f "$word" | sort)
            files=1
            ;;
        "scaler")
            wordlist="crop distort fit_contain contain forced_cover cover"
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word")
            ;;
        "sort")
            wordlist="name time size extension"
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word")
            ;;
        "ucollage")
            wordlist=${!colon_cmd[*]}
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word" | sort)
            ;;
        "toggle")
            wordlist="names prompt reverse"
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word")
            ;;
        "batch")
            wordlist="previous next first last"
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word")
            ;;
        "grid")
            wordlist="increase decrease lines columns both"
            mapfile -t autocomplete < <(IFS=" " compgen -W "$wordlist" "$word")
            ;;
    esac

    autocomplete=("$input_left" "${autocomplete[@]}")
    [[ "${#split_left[@]}" -gt 0 ]] && unset "split_left[-1]"
    local i=1
    while [[ "$i" -lt ${#autocomplete[@]} ]]
    do
        if [[ "$files" -eq 1 ]] #only escape filenames
        then
            autocomplete[$i]=$(escape_name "${autocomplete[$i]}")
        fi
        [[ "${#split_left[@]}" -gt 0 ]] && autocomplete[$i]="${split_left[*]} ${autocomplete[$i]}"
        (( i += 1 ))
    done
    suggestion_index=0
    suggestion_count=${#autocomplete[@]}
    return 0
}

######################################################################
# Gets input from the user
# Modifies:
#   input
# Arguments:
#   $1              text to show as prompt
#   $2              text to have already in the input line
#   $3              suggestion type (command, file, etc.)
# Outputs:
#   None
# Return:
#   0               if input is meaningful
#   1               if input is not meaningful
######################################################################
get_input() {
    printf "\e[?25h%s\e7" "$input_prompt"
    while [[ "$exit_flag" -eq 0 ]]
    do
        printf "\e8\e[K"
        move=""
        [[ -n "$input_right" ]] && move="\e[${#input_right}D"
        if [[ -n "$suggestion" ]]
        then
            printf "%s%s$move" "$suggestion" "$input_right"
        elif [[ -n "$input_history" ]]
        then
            printf "%s" "$input_history"
        else
            printf "%s%s$move" "$input_left" "$input_right"
        fi
        read -rsN1 -t 0.01 char &>/dev/null
        read -rsN1 -t 0.0001 k1 &>/dev/null
        read -rsN1 -t 0.0001 k2 &>/dev/null
        read -rsN1 -t 0.0001 k3 &>/dev/null
        read -rsN1 -t 0.0001 k4 &>/dev/null
        read -rsN1 -t 0.0001 k5 &>/dev/null
        read -rsN1 -t 0.0001 k6 &>/dev/null
        key="${char}${k1}${k2}${k3}${k4}${k5}${k6}"
        [[ -z "$key" ]] && continue
        case "$key" in
            $'\e[A') #up arrow press
                if [[ "$mode" == "command" ]]
                then
                    if [[ "${#cmd_history[@]}" -eq 0 ]]
                    then
                        mapfile -t cmd_history < \
                            <(grep "^${input_left}${input_right}" \
                            "$cache_dir/cmd_history" | uniq)
                        cmd_history_index=${#cmd_history[@]}
                    fi
                    ((cmd_history_index -= 1))
                    [[ "$cmd_history_index" -lt 0 ]] && cmd_history_index=0
                    input_history=${cmd_history[$cmd_history_index]}
                fi
                ;;
            $'\e[B') #down arrow press
                if [[ "$mode" == "command" ]]
                then
                    [[ "${#cmd_history[@]}" -eq 0 ]] && continue
                    ((cmd_history_index += 1))
                    [[ "$cmd_history_index" -gt ${#cmd_history[@]} ]] && cmd_history_index=${#cmd_history[@]}
                    input_history=${cmd_history[$cmd_history_index]}
                fi
                ;;
            $'\e[D') #left arrow press
                clear_suggestions
                clear_history
                if [[ -n "$input_left" ]]
                then
                    input_right="${input_left: -1}$input_right"
                    input_left="${input_left:0:-1}"
                fi
                ;;
            $'\e[C') #right arrow press
                clear_suggestions
                clear_history
                if [[ -n "$input_right" ]]
                then
                    input_left="$input_left${input_right:0:1}"
                    input_right="${input_right:1}"
                fi
                ;;
            $'\e[H'|$'\e[1~') #Home
                clear_suggestions
                clear_history
                input_right="${input_left}${input_right}"
                input_left=""
                ;;
            $'\e[F'|$'\e[4~') #End
                clear_suggestions
                clear_history
                input_left+="${input_right}"
                input_right=""
                ;;
            $'\e[3~'|$'\e[P')
                clear_suggestions
                clear_history --force
                [[ -n "$input_right" ]] && input_right="${input_right:1}"
                ;;
            $'\e')
                clear_suggestions
                clear_history --force
                input=
                break
                ;;
            $'\b'|$'\x7F'|$'')
                clear_suggestions
                clear_history --force
                [[ -n "$input_left" ]] && input_left="${input_left:0:-1}"
                ;;
            $'\n')
                clear_suggestions
                clear_history --force
                input="${input_left}${input_right}"
                break
                ;;
            [[:print:]])
                clear_suggestions
                clear_history --force
                input_left+="$key"
                ;;
            $'')
                input_left=
                ;;
            $'\t')
                [[ -z "$input_autocomplete" ]] && continue
                [[ ${#autocomplete[@]} -gt 0 ]] && set_suggestion next && continue
                ! create_suggestions && continue || set_suggestion next
                ;;
            $'\e[Z')
                [[ -z "$input_autocomplete" ]] && continue
                [[ ${#autocomplete[@]} -gt 0 ]] && set_suggestion prev && continue
                ! create_suggestions && continue || set_suggestion prev
                ;;
            *)
                ;;
        esac
    done
    input_left=
    input_right=
    input_autocomplete=
    trim_spaces input
    [[ -z "$input" ]] && return 1 || return 0
}

is_natural() {
    [[ "$1" =~ ^([1-9][0-9]*|0+[1-9][0-9]*)$ ]]
}

######################################################################
# Ask the user to set the grid size
# Uses:
#   fit_vertical
#   fit_horizontal
# Modifies:
#   new_fit_vertical
#   new_fit_horizontal
######################################################################
change_dimensions() {
    [[ "$prefix" =~ ^(\*+)$ ]] && prefix=
    clear_status --cmdline
    if [[ -z "$prefix" ]]
    then
        old_fit_vertical="$fit_vertical"
        old_fit_horizontal="$fit_horizontal"
        new_fit_vertical="$fit_vertical"
        new_fit_horizontal="$fit_horizontal"
        input_prompt="Grid dimensions # "
        if get_input
        then
            local fit
            IFS=" " read -r -a fit <<< "$input"
            if ! is_natural "${fit[0]}"
            then
                error="NaN: ${fit[0]}"
            elif ! is_natural "${fit[1]}"
            then
                error="Nan: ${fit[1]}"
            else
                [[ ! "${fit[0]}" -eq "$fit_vertical" ]] && (( new_fit_vertical = fit[0] ))
                [[ ! "${fit[1]}" -eq "$fit_horizontal" ]] && (( new_fit_horizontal = fit[1] ))
            fi
        fi
    else
        IFS=" " read -r -a prefix_args <<< "$prefix"
        (( new_fit_vertical = prefix_args[0] ))
        (( new_fit_horizontal = prefix_args[1] ))
    fi
    new_start="$start"
    maybe_redraw
    clear_sequence
    update_status
}

######################################################################
# Draws filenames under the images on the screen
# Uses:
#   line_names
######################################################################
print_names() {
    read -r lines columns < <(stty size)
    for ((i = 4; i <= lines; i++))
    do
        printf "\e[B\e[%s;1H" "$i"
        # not using %s because I want to parse the escape characters
        printf "${line_names[$((i - 4))]}"
    done
}

######################################################################
# Update the filenames to account for batch changes or file renaming
# Uses:
#   show_names
#   fit_vertical
#   fit_horizontal
#   start
#   show
#   image_names
#   photo_columns
# Modifies:
#   line_names
# Return:
#   0               if names where modified
#   1               if the function is unnecessary in a context
######################################################################
modify_names() {
    [[ "$show_names" -eq 0 ]] || [[ "$batch" -eq 1 ]] && return 1
    read -r lines columns < <(stty size)
    line_names=()
    local i
    local j

    (( total_lines = (show - 1) / fit_horizontal + 1))
    line_names[0]="┌"
    line_names[$((total_lines * photo_lines))]="└"
    for ((j = 1; j < columns - 1; j++))
    do
        line_names[0]+="─"
        line_names[$((total_lines * photo_lines))]+="─"
    done
    line_names[0]+="┐"
    line_names[$((total_lines * photo_lines))]+="┘"

    cnt=0
    for ((i = 1; i < total_lines * photo_lines; i++))
    do
        local current_in_line=0
        if ((i % photo_lines == 0))
        then
            line_names[$i]="├"
            for ((j = 1; j < columns - 1; j++))
            do
                line_names[$i]+="─"
            done
            line_names[$i]+="┤"
        elif ((i % photo_lines ==  photo_lines - 1))
        then
            line_names[$i]="│"
            ((row = (i - 1) / photo_lines))
            for ((j = 0; j < fit_horizontal; j++, cnt++))
            do
                (( index = start + row * fit_horizontal + j))
                if [[ "$cnt" -lt "$show" ]]
                then
                    current_name="$((index + 1 - start)): $(basename "${image_names[$index]}")"
                    [[ -n ${edits[$index]} ]] && current_name="~ ${current_name}"
                    [[ -n ${tags[$index]} ]] && current_name="* ${current_name}"
                    (( max_length = photo_columns - 2 ))
                    current_name=${current_name:0:$max_length}
                    namelength="${#current_name}"
                    if (( index + 1 - start == current))
                    then
                        current_name="\e[7m$current_name\e[m"
                        current_in_line=1
                    fi
                    pad_sides $((photo_columns - namelength))
                    line_names[$i]+="$current_name"
                fi
            done
            linelength=${#line_names[$i]}
            # substract the inversion escape chars
            [[ "$current_in_line" -eq 1 ]] && ((linelength -= 9)) 
            for ((j = linelength; j < columns - 1; j++))
            do
                line_names[$i]+=" "
            done
            line_names[$i]+="│"
        else
            line_names[$i]="│"
            for ((j = 1; j < columns - 1; j++))
            do
                line_names[$i]+=" "
            done
            line_names[$i]+="│"

        fi
    done

    for ((i = total_lines * photo_lines + 1; i < lines - 3; i++))
    do
        line_names[$i]=
        for ((j = 0; j < columns; j++))
        do
            line_names[$i]+=" "
        done
    done
    return 0
}

update_names() {
    modify_names && print_names || clear_names
}

redraw() {
    calculate_dimensions
    show_batch
    update_names
}

######################################################################
# Checks whether a redraw is necessary
# Uses:
#   new_fit_vertical
#   new_fit_horizontal
#   new_start
#   fit_vertical
#   fit_horizontal
#   start
#   batch
# Modifies:
#   wide_vertical
#   wide_horizontal
#   wide_start
#   fit_vertical
#   fit_horizontal
#   start
######################################################################
maybe_redraw() {
    read -r lines columns < <(stty size)
    if (( new_fit_vertical != fit_vertical )) \
        || (( new_fit_horizontal != fit_horizontal )) \
        || (( new_start != start ))
    then
        (( new_fit_vertical > max_fit_vertical )) && \
            error="Maximum number of lines set to $max_fit_vertical" && return
        (( new_fit_vertical < 1 )) && return
        (( new_fit_horizontal > max_fit_horizontal )) && \
            error="Maximum number of columns set to $max_fit_vertical" && return
        (( new_fit_horizontal < 1 )) && return
        if [[ "$new_fit_vertical" -eq 1 && "$new_fit_horizontal" -eq 1 && "$batch" -gt 1 ]]
        then
            wide_vertical="$fit_vertical"
            wide_horizontal="$fit_horizontal"
            wide_start="$start"
            wide_current="$current"
        fi
        (( wide_batch = wide_vertical * wide_horizontal ))
        if [[ "$wide_batch" -gt 0 ]]
        then
            while (( new_start >= wide_start + wide_batch ))
            do
                (( wide_start = wide_start + wide_batch ))
            done
            while (( new_start < wide_start ))
            do
                (( wide_start = wide_start - wide_batch ))
            done
        fi
        old_fit_vertical="$fit_vertical"
        old_fit_horizontal="$fit_horizontal"
        fit_vertical="$new_fit_vertical"
        fit_horizontal="$new_fit_horizontal"
        start="$new_start"
        redraw
    fi
}

######################################################################
# Set information relating to the current view
# Uses:
#   fit_vertical
#   fit_horizontal
#   start
#   image_names
#   prefix
# Modifies:
#   info
######################################################################
set_info() {
    ((begin = start + 1))
    info=" $fit_vertical x $fit_horizontal"
    if in_monocle
    then
        local photo_name
        photo_name=$(basename "${image_names[$start]}")
        [[ -n ${edits[$start]} ]] && photo_name="~ ${photo_name}"
        [[ -n ${tags[$start]} ]] && photo_name="* ${photo_name}"
        info+=" │ $begin/$total │ ${photo_name}"
    else
        ((finish = begin + show - 1))
        info+=" │ [$begin-$finish]/$total"
    fi
    local tlen=${#tags[@]}
    local elen=${#edits[@]}
    [[ "$tlen" -gt 0 ]] && info+=" │ * ${tlen}"
    [[ "$elen" -gt 0 ]] && info+=" │ ~ ${elen}"
    local padding
    local length
    length=${#info}
    read -r lines columns < <(stty size)
    (( padding = columns - length))
    for ((i = 0; i < padding; i++))
    do
        info+=" "
    done
}

######################################################################
# Checks whether we are in monocle mode
# Uses:
#   batch
# Modifies:
#   warning
# Arguments:
#   $1              string to set as the beginning of warning
# Return:
#   0               if we are in in monocle mode
#   1               if we are not in monocle mode
######################################################################
in_monocle() {
    [[ "$batch" -eq 1 ]] && return 0 || return 1
}

######################################################################
# Evaluate a command
# Uses:
#   exec_prompt
# Modifies:
#   error
# Arguments:
#   $1              message to show if confirm prompt is enabled
#   $2              command to execute
#   $3              message to show on successful execution
# Return:
#   0               if command was executed successfully
#   1               if command failed
######################################################################
eval_cmd() {
    local error
    if [[ "$exec_prompt" -eq 1 ]]
    then
        clear_status --cmdline
        printf "%s? (Press y/Y/Enter to confirm)" "$cmd_prompt"
        read -rsN1 ans
        [[ ! "$ans" =~ ^(y|Y|$'\n')$ ]] && return 1
    fi
    error=$(eval "$cmd" 2>&1 >/dev/null)
    [[ -z "$error" ]] && return 0 || return 1
}

######################################################################
# Checks if all indices given as input are valid
# Uses:
#   image_index
#   total
#   show
# Return:
#   0               if all indices are valid
#   1               if any index invalid
######################################################################
valid_indices() {
    local i
    for (( i = 0; i < index_count; i++ ))
    do
        if ! is_natural ${image_index[i]}
        then
            error="NaN: ${image_index[$i]}" && return 1
        elif (( image_index[i] <= 0 || image_index[i] > show ))
        then
            error="Index out of bounds: ${image_index[$i]}" && return 1

        fi
    done
    return 0
}

######################################################################
# Selects all indices given the scope
# Uses:
#   show
#   total
# Modifies:
#   image_index
######################################################################
all_indices() {
    image_index=()
    local i
    if [[ "$1" == "--global" ]]
    then
        for ((i = 1; i <= total; i++ ))
        do
            image_index+=("$i")
        done
    else
        for ((i = 1; i <= show; i++ ))
        do
            image_index+=("$i")
        done
    fi
}

######################################################################
# Set the image_index to operate on (array of indices)
# Uses:
#   prefix
#   batch
#   start
#   tags
# Modifies:
#   image_index
# Returns:
#   0               if indices are ok to be used
#   1               if an error occured (escaped input,zero count, invalid indices)
######################################################################
get_image_index() {
    unset image_index
    local i
    local star=0
    [[ "$prefix" == "#" ]] && prefix="$old_prefix"
    if [[ "$prefix" == ";" ]]
    then
        for (( i = 1; i <= total; i++ ))
        do
            ((tag_index = i - 1)) # indices start from 0 in tag array
            [[ -n ${tags[$tag_index]} ]] && image_index+=("$i")
        done
        [[ "${#image_index[@]}" -eq 0 ]] && \
            error="No tagged images" && return 1
    elif [[ "$prefix" =~ ^\*\* ]]
    then
        all_indices --global
        star=2
    elif [[ "$prefix" =~ ^\* ]]
    then
        all_indices --local
        star=1
    elif [[ -n "$prefix" ]]
    then
        IFS=" " read -r -a image_index <<< "$prefix"
        index_count=${#image_index[@]}
        ! valid_indices && return 1
    # no prefix given
    elif [[ "$batch" -eq 1 ]] # no-prefix, just the key pressed
    then
        image_index[0]=1
    else
        image_index[0]="$current"
    fi

    index_count=${#image_index[@]}
    [[ "$index_count" -eq 0 ]] && return 1

    for (( i = 0; i < index_count; i++ ))
    do
        (( image_index[i] -= 1 )) #adjust index for arrays
    done
    if [[ "$star" -lt 2 ]] ## if ** is used then the indices are correct
    then
        for (( i = 0; i < index_count; i++ ))
        do
            (( image_index[i] += start))
        done
    fi
    return 0
}

######################################################################
# Checks whether the provided index is local to the current view
# Uses:
#   start
#   show
# Arguments:
#   $1              the index to check
# Return:
#   0               if the index is local
#   1               if the index is not local
######################################################################
is_index_local() {
    (( end = start + show ))
    [[ "$1" -ge "$start" ]] && [[ "$1" -lt "$end" ]] && return 0 || return 1
}


######################################################################
# Checks whether the provided index corresponds to an image and not
# another filetype, thus image_names and images need to be updated
# together
# Uses:
#   image_names
#   images
# Arguments:
#   $1          the index to check
# Return:
#   0           if the index is an image
#   1           if the index is not an image
######################################################################
parallel_update() {
    [[ "${image_names[$1]}" == "${images[$1]}" ]] && return 0 || return 1
}

######################################################################
# Update the status line
# Uses:
#   warning
#   error
#   success
# Modifies:
#   status
# Outputs:
#   prints the status on stdout
######################################################################
update_status() {
    printf "\e[?25l"
    read -r lines columns < <(stty size)
    local new_status=""
    set_info
    new_status="\e[107;30m${info}\e[m"
    if [[ ! "$new_status" == "$status" ]] || [[ "$1" == "--force" ]]
    then
        clear_status
        status="$new_status"
        printf "$status"
    fi
    if [[ -n "$prefix" ]] && [[ -n "$mapping" ]]
    then
        prefix_status="($prefix)$mapping"
    elif [[ -n "$mapping" ]] 
    then
        prefix_status="$mapping"
    elif [[ -n "$prefix" ]]
    then
        prefix_status="($prefix)"
    else
        prefix_status=
    fi
    new_cmd_status="\e[H\e[B\e[2K"
    if [[ -n "$success" ]]
    then
        new_cmd_status+="\e[32m${success}\e[m"
    elif [[ -n "$error" ]]
    then
        ((space = 2 * columns))
        [[ "${#error}" -gt "$space" ]] && error="${error:0:$space}"
        new_cmd_status="\e[31m${error}\e[m"
    elif [[ -n "$warning" ]]
    then
        new_cmd_status+="\e[33m${warning}\e[m"
    fi
    [[ ${#prefix_status} -gt 30 ]] && prefix_status=${prefix_status: -30}
    [[ ! "$mapping" =~ ^(;)$ ]] && \
        new_cmd_status+="\e[$((columns - 20))C${prefix_status}"
    if [[ ! "$new_cmd_status" == "$cmd_status" ]]
    then
        clear_status --cmdline
        cmd_status+="$new_cmd_status"
        printf "$new_cmd_status"
    fi
    success=""
    error=""
    warning=""
}

run_use_script() {
    clear_status --cmdline
    if [[ ! "$mode" == "command" ]]
    then
        entry="${use_script[$mapping]}"
        IFS=';' read -r -a entry_arr <<< "$entry"
    else
        for i in "${!use_script[@]}"
        do
            entry="${use_script[$i]}"
            IFS=';' read -r -a entry_arr <<< "$entry"
            cmd=${entry_arr[2]}
            [[ "$cmd" == "$input" ]] && break
        done
    fi
    script=${entry_arr[0]}
    local sc_i
    local executed=0
    if get_image_index
    then
        for (( sc_i = 0; sc_i < index_count; sc_i++))
        do
            ind=${image_index[$sc_i]}
            printf "\e[H"
            cmd="${script//%in%/\"${image_names[$ind]}\"}"
            cmd_prompt="${input_prompt/\#/:}\"$(basename -a "${image_names[$ind]}" | tr '\n' ' ' | head -c-1)\""
            eval_cmd && ((executed += 1))
        done
        if [[ "$executed" -eq 0 ]]
        then
            error="No executions"
        elif [[ "$executed" -lt "$index_count" ]]
        then
            warning="Executed: $executed of $index_count"
        else
            success="Success"
        fi
    fi
    clear_sequence
    update_status
}

run_edit_script() {
    clear_status --cmdline
    if [[ ! "$mode" == "command" ]]
    then
        entry="${edit_script[$mapping]}"
        IFS=';' read -r -a entry_arr <<< "$entry"
    else
        for i in "${!edit_script[@]}"
        do
            entry="${edit_script[$i]}"
            IFS=';' read -r -a entry_arr <<< "$entry"
            cmd=${entry_arr[2]}
            [[ "$cmd" == "$input" ]] && break
        done
    fi
    script=${entry_arr[0]}
    old_exec_prompt="$exec_prompt"
    exec_prompt=0
    local edited=0
    local non_image=0
    local sc_i
    if get_image_index
    then
        for (( sc_i = 0; sc_i < index_count; sc_i++))
        do
            ind=${image_index[$sc_i]}
            level=${edits[$ind]}
            printf "\e[H"
            file="${image_names[$ind]}"
            case $file in
                (*.*) extension=${file##*.};;
                (*)   extension="";;
            esac
            read -d ' ' hash < <(head -c 100000 "$file" 2>/dev/null | xxh128sum)
            ! is_image && ((non_image += 1)) && continue
            filehash[$hash]=${image_names[$ind]}
            tmpfile="${tmp_dir}/${hash}.$((level + 1)).${extension}"
            cmd=${script//%in%/\"${images[$ind]}\"}
            cmd=${cmd//%out%/\"${tmpfile}\"}
            if eval_cmd
            then
                ((edited += 1))
                ((edits[ind] += 1))
                images[$ind]="$tmpfile"
                # now delete the other branch of the history if it exists
                ((level += 2))
                while [[ -f "${tmp_dir}/${hash}.$((level)).${extension}" ]]
                do
                    rm "${tmp_dir}/${hash}.$((level)).${extension}"
                    ((level += 1))
                done
                redraw
            fi
        done
        if [[ "$non_image" -eq "$index_count" ]]
        then
            error="Editing supported only for images"
        else
            if [[ "$edited" -eq 0 ]]
            then
                error="No images edited"
            elif [[ "$edited" -lt "$index_count" ]]
            then
                warning="Edited: $edited of $index_count"
            else
                success="Success"
            fi
        fi
    fi
    exec_prompt="$old_exec_prompt"
    clear_sequence
    update_status
}

save_edits() {
    clear_status --cmdline
    local se_i
    local saved=0
    local no_pending=0
    if get_image_index
    then
        local local_changes=0
        for (( se_i = 0; se_i < index_count; se_i++))
        do
            ind=${image_index[$se_i]}
            tmpfile=${images[$ind]}
            case $tmpfile in
                (*.*) extension=${tmpfile##*.};;
                (*)   extension="";;
            esac
            hash=${tmpfile%.*([[:digit:]]).${extension}}
            hash=${hash#${tmp_dir}/}
            original=${filehash[$hash]}
            [[ -z $original ]] && ((no_pending += 1)) && continue
            printf "\e[H"
            cmd="cp -f \"${tmpfile}\" \"${original}\""
            cmd_prompt="Save edits for ${original}"
            if eval_cmd
            then
                ((saved += 1))
                images[$ind]="${original}"
                rm "${tmp_dir}/$hash".* # delete all history
                unset edits["$ind"]
                unset filehash["$hash"]
                is_index_local "$ind" && local_changes=1
            fi
        done

        if [[ "$no_pending" -eq "$index_count" ]]
        then
            error="Nothing to save"
        else
            if [[ "$saved" -eq 0 ]]
            then
                error="No images saved"
            elif [[ "$saved" -lt "$index_count" ]]
            then
                warning="Saved: $saved of $index_count"
                [[ "$local_changes" -eq 1 ]] && update_names
            else
                success="Done"
                [[ "$local_changes" -eq 1 ]] && update_names
            fi
        fi
    fi
    clear_sequence
    update_status
}

execute() {
    clear_status --cmdline
    local ex_i
    local action="$1"
    local executed=0
    if [[ "$action" == "image" ]] # each image on its own
    then
        if get_image_index
        then
            for (( ex_i = 0; ex_i < index_count; ex_i++))
            do
                ind=${image_index[$ex_i]}
                clear_status --cmdline
                if [[ -n "$execute_cmd" ]]
                then
                    input="$execute_cmd"
                else
                    input_prompt="Command"
                    [[ "$index_count" -gt 1 ]] && input_prompt+=" for [$((ind + 1))]"
                    input_prompt+=": "
                    input_autocomplete="command"
                    ! get_input && continue
                fi
                cmd=${input//%s/\"${image_names[$ind]}\"}
                cmd=${cmd//%e/\"${images[$ind]}\"}
                cmd_prompt="$ ${cmd}"
                eval_cmd && ((executed += 1))
            done
        fi
    elif [[ "$action" == "same" ]]
    then
        if get_image_index
        then
            if [[ -n "$execute_cmd" ]]
            then
                input="$execute_cmd"
            else
                clear_status --cmdline
                input_prompt="Command: "
                input_autocomplete="command"
                get_input
            fi
            if [[ -n "$input" ]]
            then
                for (( ex_i = 0; ex_i < index_count; ex_i++))
                do
                    ind=${image_index[$ex_i]}
                    cmd=${input//%s/\"${image_names[$ind]}\"}
                    cmd=${cmd//%e/\"${images[$ind]}\"}
                    cmd_prompt="$ ${cmd}"
                    eval_cmd && ((executed += 1))
                done
            fi
        fi
    else # bundle images
        if get_image_index
        then
            local args=""
            local edit_args=""
            for (( i = 0; i < index_count; i++))
            do
                ind=${image_index[$i]}
                args+="\"${image_names[$ind]}\" "
                edit_args+="\"${images[$ind]}\" "
            done
            clear_status --cmdline
            if [[ -n "$execute_cmd" ]]
            then
                input="$execute_cmd"
            else
                input_prompt="Command: "
                input_autocomplete="command"
                ! get_input && return
            fi
            cmd=${input//%S/${args[@]}}
            cmd=${cmd//%E/${edit_args[@]}}
            cmd_prompt="$ ${cmd}"
            eval_cmd && ((executed += index_count))
        fi
    fi
    if [[ "$executed" -eq 0 ]]
    then
        error="No executions"
    elif [[ "$executed" -lt "$index_count" ]]
    then
        warning="Executed: $executed of $index_count"
    else
        success="Success"
    fi
    clear_sequence
    execute_cmd=
    update_status
}

rename() {
    clear_status --cmdline
    local update=0
    local mv_i
    if get_image_index
    then
        local renamed=0
        for (( mv_i = 0; mv_i < index_count; mv_i++))
        do
            ind=${image_index[$mv_i]}
            clear_status --cmdline
            input_prompt="New name"
            [[ "$index_count" -gt 1 ]] && input_prompt+=" for [$((ind + 1))]"
            input_prompt+=": "
            input_left="${image_names[$ind]}"
            ! get_input && continue
            if [[ "${image_names[$ind]}" == "$input" ]]
            then
                error="New name has to be different"
                update_status
                read -N1
                continue
            elif [[ -f "$input" ]]
            then
                error="Filename exists"
                update_status
                read -N1
                continue
            fi
            cmd="mv \"${image_names[$ind]}\" \"$input\""
            cmd_prompt="Rename to: ${input}"
            if eval_cmd
            then
                ((renamed += 1))
                parallel_update "$ind" && images[$ind]="$input"
                image_names[$ind]="$input"
                is_index_local "$ind" && update=1
            fi
        done
        if [[ "$renamed" -eq 0 ]]
        then
            error="No renames"
        elif [[ "$renamed" -lt "$index_count" ]]
        then
            warning="Renamed: $renamed of $index_count"
        else
            success="Success"
        fi
        [[ "$update" -eq 1 ]] && update_names
    fi
    clear_sequence
    update_status
}

goto_image() {
    clear_status --cmdline
    [[ "$prefix" =~ ^(;|\*+)$ ]] && prefix=
    if get_image_index
    then
        ((current = image_index[0] + 1))
        new_start="$image_index"
        old_fit_vertical="$fit_vertical"
        old_fit_horizontal="$fit_horizontal"
        new_fit_vertical=1
        new_fit_horizontal=1
        maybe_redraw
    fi
    clear_sequence
    update_status
}

delete_image() {
    clear_status --cmdline
    local update=0
    local del_i
    if get_image_index
    then
        local deleted=0
        for (( del_i = 0; del_i < index_count; del_i++))
        do
            (( updated = del_i - deleted )) # adjust index because we trim the arrays after deleting
            ind=${image_index[$updated]}
            cmd="mv \"${image_names[$ind]}\" \"$trash_dir\""
            cmd_prompt="Delete: ${image_names[$ind]}"
            if eval_cmd
            then
                unset image_names["${image_index[$updated]}"]
                unset images["${image_index[$updated]}"]
                image_names=("${image_names[@]}")
                images=("${images[@]}")
                total=${#images[@]}
                is_index_local "$ind" && update=1
                (( deleted += 1 ))
            fi
        done
        if [[ "$deleted" -eq 0 ]]
        then
            error="No deletions"
        elif [[ "$deleted" -lt "$index_count" ]]
        then
            warning="Deleted: $deleted of $index_count"
        else
            success="Success"
        fi
        [[ "$update" -eq 1 ]] && redraw
    fi
    clear_sequence
    update_status
}

tag_image() {
    clear_status --cmdline
    local update=0
    local i
    case $1 in
        tag)
            if get_image_index
            then
                for (( i = 0; i < index_count; i++))
                do
                    [[ -z ${tags[${image_index[$i]}]} ]] && tags[${image_index[$i]}]=1 \
                        && is_index_local "${image_index[$i]}" && update=1
                done
            fi
            ;;
        untag)
            if get_image_index
            then
                for (( i = 0; i < index_count; i++))
                do
                    [[ -n ${tags[${image_index[$i]}]} ]] && unset tags["${image_index[$i]}"] \
                        && is_index_local "${image_index[$i]}" && update=1
                done
            fi
            ;;
    esac
    [[ "$update" -eq 1 ]] && update_names
    clear_sequence
    update_status
}

edit_history() {
    clear_status --cmdline
    old_exec_prompt="$exec_prompt"
    exec_prompt=0
    if [[ "$1" == "--undo" ]]
    then
        local undone=0
        local undo_i
        if get_image_index
        then
            for (( undo_i = 0; undo_i < index_count; undo_i++))
            do
                ind=${image_index[$undo_i]}
                level=${edits[$ind]:-0}
                [[ "$level" -eq 0 ]] && continue
                file="${image_names[$ind]}"
                case $file in
                    (*.*) extension=${file##*.};;
                    (*)   extension="";;
                esac
                read -d ' ' hash < <(head -c 100000 "$file" 2>/dev/null | xxh128sum)
                if [[ "$level" -eq 1 ]]
                then
                    tmpfile="$file"
                else
                    tmpfile="${tmp_dir}/${hash}.$((level - 1)).${extension}"
                fi
                ((undone += 1))
                ((edits[ind] -= 1))
                ((edits[ind] == 0)) && unset edits["$ind"] #unset if at start of history
                images[$ind]="$tmpfile"
                redraw
            done
            if [[ "$undone" -eq 0 ]]
            then
                error="Already at oldest change"
            elif [[ "$undone" -lt "$index_count" ]]
            then
                warning="Undone: $undone of $index_count"
            else
                success="Success"
            fi
        fi
    elif [[ "$1" == "--redo" ]]
    then
        local redo_i
        if get_image_index 
        then
            local redone=0
            for (( redo_i = 0; redo_i < index_count; redo_i++))
            do
                ind=${image_index[$redo_i]}
                level=${edits[$ind]:-0}
                file="${image_names[$ind]}"
                case $file in
                    (*.*) extension=${file##*.};;
                    (*)   extension="";;
                esac
                read -r -d ' ' hash < <(head -c 100000 "$file" 2>/dev/null | xxh128sum)
                tmpfile="${tmp_dir}/${hash}.$((level + 1)).${extension}"
                [[ ! -f "$tmpfile" ]] && continue
                ((redone += 1))
                ((edits[ind] += 1))
                images[$ind]="$tmpfile"
                redraw
            done
            if [[ "$redone" -eq 0 ]]
            then
                error="Already at newest change"
            elif [[ "$redone" -lt "$index_count" ]]
            then
                warning="Redone: $redone of $index_count"
            else
                success="Success"
            fi
        fi
    fi
    exec_prompt="$old_exec_prompt"
    clear_sequence
    update_status
}

change_sort() {
    clear_status --cmdline
    local input
    if [[ -n "$1" ]]
    then
        input="$1"
    else
        input_prompt="New sort (options: "
        for opt in name time size extension
        do
            [[ "$sort_by" == "$opt" ]] && input_prompt+="*"
            input_prompt+="$opt, "
        done
        input_prompt="${input_prompt:0: -2}): "
        input_autocomplete="sort"
    fi
    if [[ -n "$input" ]] || get_input
    then
        if [[ ! "$input" =~ ^(name|time|size|extension)$ ]]
        then
            error="Invalid value for sort: $input"
        else
            local new_sort_by="$input"
            [[ ! "$new_sort_by" == "$sort_by" ]] && \
                sort_by="$new_sort_by" && \
                break_flag=1
        fi
    fi
    clear_sequence
    update_status
}

toggle() {
    clear_status --cmdline
    input="$1"
    if [[ -z "$input" ]]
    then
        input_prompt="Toggle setting # "
        input_autocomplete="toggle"
        get_input
    fi
    if [[ "$input" == "names" ]]
    then
        [[ "$show_names" -eq 1 ]] && show_names=0 || show_names=1
        redraw
    elif [[ "$input" == "prompt" ]]
    then
        [[ "$exec_prompt" -eq 1 ]] && exec_prompt=0 || exec_prompt=1
        [[ "$exec_prompt" -eq 1 ]] && success="Confirm command execution" \
            || warning="Don't confirm command execution"
    elif [[ "$input" == "reverse" ]]
    then
        [[ "$sort_reverse" -eq 1 ]] && sort_reverse=0 || sort_reverse=1
        if [[ "$done_reading" -eq 1 ]]
        then
            reverse_images
            start=0
            redraw
        else # we have not read all images so we need to go from the start
            break_flag=1
        fi
    elif [[ -n "$input" ]]
    then
        error="Unknown toggle setting: $input"
    fi
    clear_sequence
    update_status --force
}

reverse_images(){
    min=0
    (( max = ${#images[@]} -1 ))
    local temp
    while [[ min -lt max ]]
    do
        temp="${image_names[$min]}"
        image_names[$min]="${image_names[$max]}"
        image_names[$max]="$temp"

        temp="${images[$min]}"
        images[$min]="${images[$max]}"
        images[$max]="$temp"

        (( min += 1 ))
        (( max -= 1 ))
    done
}

change_scaler() {
    clear_status --cmdline
    local input
    if [[ -n "$1" ]]
    then
        input="$1"
    else
        input_prompt="New scaler (options: "
        for opt in crop distort fit_contain contain forced_cover cover
        do
            [[ "$scaler" == "$opt" ]] && input_prompt+="*"
            input_prompt+="$opt, "
        done
        input_prompt="${input_prompt:0: -2}): "
        input_autocomplete="scaler"
    fi
    if [[ -n "$input" ]] || get_input
    then
        if [[ ! "$input" =~ ^(crop|distort|fit_contain|contain|forced_cover|cover)$ ]]
        then
            error="Invalid value for scaler: $input"
        else
            local new_scaler="$input"
            if [[ ! "$new_scaler" == "$scaler" ]]
            then
                scaler="$new_scaler"
                success="Change scaler to: $scaler"
                redraw
            fi
        fi
    fi
    clear_sequence
    new_scaler=
    update_status
}

grid() {
    [[ "$prefix" =~ ^(;|\*+)$ ]] && prefix=
    [[ -z "$prefix" ]] && prefix="1"
    IFS=" " read -r -a prefix_args <<< "$prefix"
    local type=
    local element=
    while [[ -n "$1" ]] 
    do
        case "$1" in
            decrease|increase)
                type="$1"
                ;;
            lines|columns|both)
                element="$1"
                ;;
            *)
                error="Uknown parameter: $1"
                ;;
        esac
        shift
    done
    if [[ -z "$error" ]] && [[ -z "$type" ]]
    then
        clear_status --cmdline
        input_prompt="Set type (increase, decrease): "
        get_input
        case "$input" in
            decrease|increase)
                type="$input"
                ;;
            increase)
                increase=1
                ;;
            "")
                ;;
            *)
                error="Uknown parameter: $1"
                ;;
        esac
        
    fi
    if [[ -z "$error" ]] && [[ -z "$element" ]]
    then
        clear_status --cmdline
        input_prompt="Set element (lines, columns, both): "
        get_input
        case "$input" in
            lines|columns|both)
                element="$input"
                ;;
            "")
                ;;
            *)
                error="Uknown parameter: $1"
                ;;
        esac
        
    fi
    offset=0
    if [[ "$type" == "decrease" ]]
    then
        ((offset = -prefix_args[0]))
    elif [[ "$type" == "increase" ]]
    then
        ((offset = prefix_args[0]))
    fi
    new_fit_horizontal="$fit_horizontal"
    new_fit_vertical="$fit_vertical"
    case "$element" in 
        "lines")
            ((new_fit_vertical += offset))
            ;;
        "columns")
            ((new_fit_horizontal += offset))
            ;;
        "both")
            ((new_fit_vertical += offset))
            ((new_fit_horizontal += offset))
            ;;
    esac
    new_start="$start"
    maybe_redraw
    clear_sequence --keep-old
    update_status --force
}

set_current() {
    case "$1" in
        left)
            (( current % fit_horizontal != 1)) && ((current -= 1))
            ;;
        down)
            (( current + fit_horizontal <= show )) && ((current += fit_horizontal))
            ;;
        up)
            (( current - fit_horizontal >= 1 )) && ((current -= fit_horizontal))
            ;;
        right)
            ((current % fit_horizontal != 0 )) && ((current += 1))
            ;;
        "")
            get_image_index && ((current = image_index[0] + 1))
            ;;
    esac
    update_names
    clear_sequence --keep-old
    update_status
}

clear_sequence() {
    [[ "$1" != "--keep-old" ]] && old_prefix="$prefix" && old_mapping="$mapping"
    prefix=
    mapping=
}

######################################################################
# Populate the image_names and images arrays by reading the files
# written by the background process
# Uses:
#   tmp_dir
# Modifies:
#   image_names
#   images
#   done_reading
#   total
######################################################################
populate_arrays() {
    # This is to read only new files in each iteration. Should scale well
    [[ ! -f "${tmp_dir}/image_names.txt" ]] || [[ ! -f "${tmp_dir}/images.txt" ]] && return
    mv "${tmp_dir}/image_names.txt" "${tmp_dir}/image_names.txt.old"
    mv "${tmp_dir}/images.txt" "${tmp_dir}/images.txt.old"
    mapfile -t temp_names < "${tmp_dir}/image_names.txt.old"
    mapfile -t temp < "${tmp_dir}/images.txt.old"
    image_names+=("${temp_names[@]}")
    images+=("${temp[@]}")
    [[ -f "${tmp_dir}/done_reading" ]] && done_reading=1 || done_reading=0
    total="${#images[@]}"
}

######################################################################
# Loop waiting for user input to execute actions
# Uses:
#   fit_vertical
#   fit_horizontal
#   prefix
# Modifies:
#   new_start
#   new_fit_vertical
#   new_fit_horizontal
#   prefix
######################################################################
read_key() {
    while true
    do
        [[ "$break_flag" -eq 1 ]] && break
        [[ "$exit_flag" -eq 1 ]] && break
        [[ "$total" -eq 0 ]] && stop_daemon
        read -rsN1 -t 0.01 char &>/dev/null
        read -rsN1 -t 0.0001 k1 &>/dev/null
        read -rsN1 -t 0.0001 k2 &>/dev/null
        read -rsN1 -t 0.0001 k3 &>/dev/null
        read -rsN1 -t 0.0001 k4 &>/dev/null
        read -rsN1 -t 0.0001 k5 &>/dev/null
        read -rsN1 -t 0.0001 k6 &>/dev/null
        key="${char}${k1}${k2}${k3}${k4}${k5}${k6}"
        [[ -z "$key" ]] && [[ "$done_reading" -eq 1 ]] && continue
        case $key in
            [0-9]|" ")
                [[ -z "$mapping" ]] && prefix+="$key"
                mode="normal"
                update_status
                ;;
            "*")
                if [[ "$prefix" =~ ^\*+$ ]]
                then
                    [[ -z "$mapping" ]] && prefix="**"
                else
                    [[ -z "$mapping" ]] && prefix="*"
                fi
                mode="normal"
                update_status
                ;;
            ";")
                [[ -z "$mapping" ]] && prefix=";"
                mode=normal
                update_status
                ;;
            "#")
                [[ -z "$mapping" ]] && prefix="#"
                mode=normal
                update_status
                ;;
            ":")
                mode="command"
                update_status
                printf "\e[H\e[B"
                input_prompt=":"
                [[ -n "$prefix" ]] && input_left="($prefix) "
                input_autocomplete="ucollage"
                if get_input
                then
                    save_input=
                    prefix=${input#*\(}
                    prefix=${prefix%%)*}
                    trim_spaces prefix
                    [[ "$prefix" == "$input" ]] && prefix=
                    [[ -n "$prefix" ]] && save_input+="($prefix) "
                    cmd=${input#*)}
                    trim_spaces cmd
                    save_input+="$cmd"
                    if [[ -n "$cmd" ]]
                    then
                        echo "$save_input" >> "$cache_dir/cmd_history"
                        if [[ -n ${colon_cmd["$cmd"]} ]]
                        then
                            eval "${colon_cmd["$cmd"]}"
                        elif [[ "$cmd" =~ ^!% ]] # this is the same as execute group
                        then
                            execute_cmd=${cmd#!%}
                            execute group
                        elif [[ "$cmd" =~ ^! ]] # this is the same as execute same
                        then
                            execute_cmd=${cmd#!}
                            execute same
                        elif [[ "$cmd" =~ ^scaler ]]
                        then
                            eval_param=scaler
                            eval "${colon_cmd[$eval_param]} ${cmd##$eval_param*( )}"
                        elif [[ "$cmd" =~ ^sort ]]
                        then
                            eval_param=sort
                            eval "${colon_cmd[$eval_param]} ${cmd##$eval_param*( )}"
                        elif [[ "$cmd" =~ ^toggle ]]
                        then
                            eval_param=toggle
                            eval "${colon_cmd[$eval_param]} ${cmd##$eval_param*( )}"
                        elif [[ "$cmd" =~ ^batch ]]
                        then
                            eval_param=batch
                            eval "${colon_cmd[$eval_param]} ${cmd##$eval_param*( )}"
                        elif [[ "$cmd" =~ ^grid ]]
                        then
                            eval_param=grid
                            eval "${colon_cmd[$eval_param]} ${cmd##$eval_param*( )}"
                        else
                            error="Command not found: $cmd"
                            mode="normal"
                            prefix=
                            clear_sequence
                        fi
                    fi
                else
                    mode="normal"
                    clear_sequence
                    update_status --force
                fi
                continue
                ;;
            $'\b'|$'\x7F')
                if [[ -n "$mapping" ]]
                then
                    mapping=${mapping:0:-1}
                elif [[ -n "$prefix" ]]
                then
                    prefix=${prefix:0:-1}
                elif [[ "$batch" -eq 1 ]]
                then
                    old_fit_vertical="$fit_vertical"
                    old_fit_horizontal="$fit_horizontal"
                    fit_vertical="$wide_vertical"
                    fit_horizontal="$wide_horizontal"
                    start="$wide_start"
                    current="$wide_current"
                    redraw
                    clear_sequence
                fi
                update_status
                ;;
            $'\e')
                clear_sequence --keep-old
                mode="normal"
                update_status
                ;;
            *)
                mapping+="$key"
                ;;
        esac
        if [[ -n "$mapping" ]] && [[ -n "${use_script[$mapping]}" ]]
        then
            run_use_script
        fi
        if [[ -n "$mapping" ]] && [[ -n "${edit_script[$mapping]}" ]]
        then
            run_edit_script
        fi
        [[ "$mapping" == "." ]] && mapping="$old_mapping"
        case $mapping in
            q)
                exit_flag=1
                ;;
            h|j|k|l|$'\e[A'|$'\e[B'|$'\e[C'|$'\e[D')
                case "$mapping" in
                    h|$'\e[D')
                        keyword=left
                        ;;
                    j|$'\e[B')
                        keyword=down
                        ;;
                    k|$'\e[A')
                        keyword=up
                        ;;
                    l|$'\e[C')
                        keyword=right
                        ;;
                esac
                set_current "$keyword"
                ;;
            n|N|p|P|$'\e[1;5C'|$'\e[1;5D'|$'\e[1;6C'|$'\e[1;6D')
                case $mapping in
                    n|$'\e[1;5C')
                        keyword=next
                        ;;
                    N|$'\e[1;6C')
                        keyword=last
                        ;;
                    p|$'\e[1;5D')
                        keyword=previous
                        ;;
                    P|$'\e[1;6D')
                        keyword=first
                        ;;
                esac
                compute_batch "$keyword"
                ;;
            sg)
                change_dimensions
                ;;
            ++)
                grid increase both
                ;;
            --)
                grid decrease both
                ;;
            +_)
                grid increase lines
                ;;
            -_)
                grid decrease lines
                ;;
            +\|)
                grid increase columns
                ;;
            -\|)
                grid decrease columns
                ;;
            r|R)
                if ! command -v convert &> /dev/null
                then
                    error="imagemagick not installed: required for rotation of images"
                    update_status
                    read -N1
                    continue
                fi
                run_edit_script
                ;;
            xs)
                execute same
                ;;
            xi)
                execute image
                ;;
            xg)
                execute group
                ;;
            ci)
                rename
                ;;
            di)
                delete_image
                ;;
            dt)
                tag_image untag
                ;;
            ti)
                tag_image tag
                ;;
            si)
                set_current
                ;;
            u)
                edit_history --undo
                ;;
            $'')
                edit_history --redo
                ;;
            ss)
                change_sort
                ;;
            tr)
                toggle reverse
                ;;
            tn)
                toggle names
                ;;
            su)
                change_scaler
                ;;
            tp)
                toggle prompt
                ;;
            wi)
                save_edits
                ;;
            $'\n')
                goto_image
                ;;
            *)
                [[ -n "$mapping" ]] && update_status
                ;;
        esac
        if [[ ! "$done_reading" -eq 1 ]] && [[ ! "$exit_flag" -eq 1 ]]
        then
            populate_arrays
            update_status
        fi
    done
}

init() {
    calculate_dimensions
    show_batch
    clear_screen
    update_status
    update_names
    read_key
}

check_dependencies
parse_config
set_defaults
[[ ! -d "$tmp_dir" ]] && mkdir -p "$tmp_dir"
[[ ! -d "$cache_dir" ]] && mkdir -p "$cache_dir"
[[ ! -d "$trash_dir" ]] && mkdir -p "$trash_dir"
[[ ! -d "${cache_dir}/hash/images" ]] && mkdir -p "${cache_dir}/hash/images"
[[ ! -d "${cache_dir}/hash/videos" ]] && mkdir -p "${cache_dir}/hash/videos"
[[ ! -d "${cache_dir}/hash/other" ]] && mkdir -p "${cache_dir}/hash/other"
[[ ! -d "${cache_dir}/thumbnails" ]] && mkdir -p "${cache_dir}/thumbnails"
[[ ! -f "${cache_dir}/cmd_history" ]] && touch "${cache_dir}/cmd_history"
[[ "$1" =~ ^-h$|^--help$ ]] && help && exit
trap "exit_flag=1" SIGINT SIGTERM
trap "redraw; update_status --force" SIGWINCH
start_daemon
exit_flag=0
while [[ "$exit_flag" -eq 0 ]]
do
    read_filenames "$@"
    stty -echo
    unset start #make sure that start is not set, makes check in read_images
    (( first_batch = fit_vertical * fit_horizontal ))
    read_target="$first_batch" && read_images
    populate_arrays
    if [[ "$total" -eq 1 ]]
    then
        fit_vertical=1
        fit_horizontal=1
        old_fit_vertical=1
        old_fit_horizontal=1
        wide_vertical=1
        wide_horizontal=1
    fi
    unset read_target && read_images --remaining &
    background_pid="$!"
    [[ "$total" -eq 0 ]] && printf "No images to show" && stty echo && exit_clear=0 && break
    start=0
    declare -A assoc
    mode="normal"
    break_flag=0
    current=1
    init
done
stop_daemon
